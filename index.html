<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CWE Production Dashboard</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --bg-main: #1F2937; /* Dark Slate-800 */
            --bg-card: #374151; /* Dark Slate-700 */
            --text-primary: #F3F4F6; /* Light Slate-100 */
            --text-secondary: #9CA3AF; /* Medium Slate-400 */
            --border-color: #4B5563; /* Dark Slate-600 */
            --border-color-strong: #6B7280; /* Dark Slate-500 */
            --accent-primary: #3B82F6; /* A strong, modern blue */
            --accent-primary-hover: #2563EB;
            --accent-success: #10B981;
            --accent-success-hover: #059669;
            --accent-danger: #EF4444;
            --accent-danger-hover: #DC2626;
            --disabled-bg: #4B5563;
            --disabled-text: #9CA3AF;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.15);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.2), 0 2px 4px -2px rgb(0 0 0 / 0.2);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.25), 0 4px 6px -4px rgb(0 0 0 / 0.25);
            --font-family-sans: 'Inter', sans-serif;
        }

        /* Base & Typography */
        body {
            font-family: var(--font-family-sans);
            line-height: 1.6;
            background-color: var(--bg-main);
            color: var(--text-primary);
            padding: 0;
            margin: 0;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        h1, h2, h3, h4 {
            color: var(--text-primary);
            font-weight: 600;
            margin-top: 0;
        }
        h1 { font-size: 2.25rem; letter-spacing: -0.02em; }
        h2 { font-size: 1.875rem; letter-spacing: -0.01em; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.125rem; color: var(--text-secondary); }
        p { color: var(--text-secondary); margin-bottom: 1.25rem; }
        small { font-size: 0.875rem; color: var(--text-secondary); }
        hr { border: 0; border-top: 1px solid var(--border-color); margin: 2rem 0; }

        /* Card & Container Styles */
        .card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem; /* Larger radius for modern look */
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-md);
            transition: box-shadow 0.3s ease;
        }
        .card:hover {
            box-shadow: var(--shadow-lg);
        }

        #header-container {
            background-color: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
            margin-bottom: 2rem;
            position: relative;
            text-align: center;
        }

        #header-logo {
            max-width: 250px;
            margin-bottom: 1rem;
        }

        #output, #review-container, #casting-config-container, #sticker-settings-container, #casting-layout-container {
            display: none;
        }

        /* Buttons */
        button {
            font-family: var(--font-family-sans);
            font-weight: 600;
            font-size: 0.95rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        button:focus-visible {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }
        .btn-primary {
            background-color: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }
        .btn-primary:hover {
            background-color: var(--accent-primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        .btn-success {
            background-color: var(--accent-success);
            color: white;
        }
        .btn-success:hover {
            background-color: var(--accent-success-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        .btn-secondary {
            background-color: var(--bg-card);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        .btn-secondary:hover {
            background-color: var(--bg-main);
            border-color: var(--border-color-strong);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Forms & Inputs */
        .input-option { margin-bottom: 2rem; }
        .paste-area { margin-top: 1rem; }
        .paste-area label, label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        input[type="text"], input[type="number"], input[type="file"], textarea, select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            background-color: var(--bg-card);
            color: var(--text-primary);
            font-family: var(--font-family-sans);
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
        }
        input[type="file"] {
            padding: 0.5rem;
            background-color: var(--bg-main);
        }
        input:focus-visible, textarea:focus-visible, select:focus-visible {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }
        ::placeholder { color: var(--text-secondary); opacity: 0.7; }

        /* Tables */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: var(--bg-main);
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: var(--bg-card);
        }
        tr:nth-child(odd) {
            background-color: #4B5563; /* Slightly different for odd rows */
        }

        /* Specific Component Styles */
        #output-controls {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-md);
            display: none; /* Hidden by default */
        }
        #review-actions {
            display: none;
            position: sticky;
            top: 1rem;
            background-color: rgba(55, 65, 81, 0.8); /* --bg-card with alpha */
            backdrop-filter: blur(8px);
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            z-index: 99;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }
        .template-link {
            text-decoration: none;
            padding: 0.6rem 1.2rem;
            background-color: var(--bg-main);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .template-link:hover {
            background-color: var(--bg-card);
            border-color: var(--border-color-strong);
            box-shadow: var(--shadow-sm);
        }

        /* Casting Layout Visualization */
        #casting-layout-container h2 { margin-bottom: 1rem; }
        #casting-layout-container p { margin-bottom: 1.5rem; }
        .canvas-wrapper {
            position: relative;
            width: 100%;
            padding-top: 50%; /* Aspect Ratio 2:1 */
            background-color: #111827; /* Darker for contrast */
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
        }
        .casting-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #layout-controls {
            margin-bottom: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #layout-controls .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        #form-info-box {
            position: absolute;
            display: none;
            background: rgba(26, 26, 26, 0.85);
            backdrop-filter: blur(4px);
            border: 1px solid var(--border-color-strong);
            padding: 0.75rem;
            border-radius: 0.5rem;
            color: #F0F2F5;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 110;
            box-shadow: var(--shadow-lg);
        }

        /* Sticker Styles */
        .sticker-sheet-container { display: none; padding: 20px; }
        .sticker-sheet {
            display: flex;
            flex-wrap: wrap;
            gap: 0;
            width: 8.5in;
            min-height: 11in;
            margin: auto;
            background-color: #fff;
            box-shadow: var(--shadow-lg);
        }
        .sticker {
            box-sizing: border-box;
            width: 2in;
            height: 1in;
            border: 1px solid #ccc;
            padding: 4px;
            font-size: 7pt;
            color: #000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .sticker-header { display: flex; justify-content: space-between; font-weight: bold; }
        .sticker-dims { font-size: 6.5pt; }
        .sticker-body { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; }
        .sticker-footer { display: flex; justify-content: space-between; font-size: 6.5pt; }
        .qc-boxes { display: flex; justify-content: space-around; margin-top: 3px; }
        .qc-box { border: 1px solid #000; width: 12px; height: 12px; font-size: 6pt; text-align: center; line-height: 10px; }

        /* Print Styles */
        @media print {
            body {
                padding: 0; margin: 0; font-size: 10pt;
                background-color: #fff !important; color: #000 !important;
            }
            * { color: #000 !important; background-color: #fff !important; box-shadow: none !important; }
            .main-container { padding: 0.5in; max-width: 100%; }
            #header-container, #review-actions, #output-controls, #input-container, .explanation-section, #print-note, #casting-layout-container, .card {
                display: none !important;
            }
            #printable-layout-container, #output[style*="display: block"], #sticker-sheet-container[style*="display: block"], #tracking-sheet-container[style*="display: block"] {
                display: block !important; border: none; padding: 0; margin: 0;
            }
            h3, h4 { page-break-after: avoid; font-size: 12pt; }
            table.schedule-table { width: 100% !important; font-size: 8pt; border-collapse: collapse; }
            .schedule-table tr { page-break-inside: avoid; }
            .schedule-table th, .schedule-table td { padding: 2px 4px; border: 1px solid #000 !important; }
            .schedule-table th { background-color: #eee !important; }
            .cast-schedule-print-container, .tracking-sheet-print-container, .printable-cast-layout { page-break-after: always; }
            #output .cast-schedule-print-container:last-of-type, #tracking-sheet-container .tracking-sheet-print-container:last-of-type, .printable-cast-layout:last-of-type { page-break-after: avoid; }
            .sticker { page-break-inside: avoid; }
            @page schedule-page { size: letter landscape; margin: 0.25in; }
            #output { page: schedule-page; }
            /* @page sticker-page is now generated dynamically in the script. */
            .sticker-sheet-container { page: sticker-page; }
            @page tracking-sheet-page { size: letter landscape; margin: 0.25in; }
            #tracking-sheet-container { page: tracking-sheet-page; }
            @page { size: landscape; margin: 0.5in; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded"></script>
</head>
<body>
    <div class="main-container">
        <div id="input-container" class="card">
        <div id="header-container">
            <img src="https://www.concreteworkseast.com/wp-content/uploads/2024/07/PNG-White-Color-Transparent-Background-1.png" alt="CWE Logo" id="header-logo">
            <h1>CWE Production Dashboard</h1>
            <p>This application helps optimize panel production by generating efficient casting schedules, tracking sheets, and production stickers.</p>
            <div class="action-buttons">
                <button id="generate-schedule" class="btn-primary" disabled>Generate Schedule</button>
            </div>
            <div class="input-option">
                <h3>Upload Project Data</h3>
                <p>Upload your project's <strong>Excel (.xlsx)</strong> file. This file should contain your Project Information and Panel Legend.</p>
                <p><small><b>For Excel:</b> Ensure your data is on sheets named "Project Information" and "Panel Legend". A casting schedule is optional and will be generated if not provided.</small></p>
                <input type="file" id="file-input" accept=".xlsx,.xls">
                <p><small><b>To export from Google Sheets:</b> Open your sheet, go to <i>File > Download > Microsoft Excel (.xlsx)</i>.</small></p>
                <div class="template-link-container">
                    <a href="https://docs.google.com/spreadsheets/d/1etTFuqcqPBHPw2U1r-XG92rKT9JYsUP_-QtnDHiNczk/edit?usp=sharing" class="template-link" target="_blank">Get Project Panel List Template</a>
                </div>
            </div>
            <div class="input-option">
                <h3>Connect to Google Drive</h3>
                <p><strong>Step 1:</strong> Sign in with your Google account to securely access your Drive files.</p>
                <button id="authorize-button" class="btn-primary" style="display: none; margin-right: 0.5rem;">Sign in with Google</button>
                <button id="signout-button" class="btn-secondary" style="display: none;">Sign Out</button>

                <div id="drive-controls" style="margin-top: 1.5rem;">
                    <p><strong>Step 2:</strong> Provide a link to a Google Drive folder to find and load your sheet.</p>
                    <input type="text" id="google-drive-folder-url-input" placeholder="Sign in to enable" disabled>
                    <button id="get-sheets-button" class="btn-secondary" style="margin-top: 1rem;" disabled>Find Sheets in Folder</button>
                    <div id="sheet-list-container" style="display: none; margin-top: 1.5rem;">
                        <h4>Select a Google Sheet</h4>
                        <div id="sheet-list" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 0.5rem; padding: 1rem; background-color: var(--bg-main);"></div>
                        <button id="load-selected-sheet" class="btn-success" style="margin-top: 1rem;" disabled>Load Selected Sheet</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="output-controls" class="card">
        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; flex-wrap: wrap; gap: 1rem;">
            <div id="nav-left-controls" style="display: flex; gap: 0.5rem; align-items: center;">
                <button id="start-over" class="btn-secondary">Start Over</button>
                <button id="back-to-schedule-button" class="btn-secondary" style="display: none;">Back to Schedule</button>
                <button id="back-to-review-button" class="btn-secondary">Back to Review</button>
                <button id="back-to-build-details-button" class="btn-secondary" style="display: none;">Back to Build Details</button>
            </div>
            <div id="nav-middle-controls" style="display: flex; gap: 0.5rem; align-items: center;">
                <button id="print-schedule-button" class="btn-primary" disabled>Print Schedule</button>
                <small id="print-note" style="display: none;">(For best results, use 'Fit to page' in print preview)</small>
            </div>
            <div id="nav-right-controls" style="display: flex; gap: 0.5rem; align-items: center;">
               <button id="generate-tracking-sheet-button" class="btn-secondary" disabled>Generate Tracking Sheet</button>
               <button id="generate-stickers-button" class="btn-secondary" disabled>Generate Stickers</button>
               <button id="view-layout-button" class="btn-secondary" disabled>View Casting Layout</button>
            </div>
        </div>
    </div>
    <div id="review-actions">
        <button id="cancel-review" class="btn-secondary">Back</button>
        <button id="confirm-generate" class="btn-success">Confirm and Generate Schedule</button>
    </div>
    <div id="review-container" class="card">
        <h2>Confirm Project Data</h2>
        <p>Review the parsed Project Information, Panel Legend, and Casting Schedule. If correct, click "Confirm and Generate Schedule" to proceed to optimization settings.</p>
        <div class="review-section">
            <h3>Project Information</h3>
            <div id="review-project-info"></div>
        </div>
        <div class="review-section">
            <h3>Panel Legend</h3>
            <div id="review-panel-legend"></div>
        </div>
        <div class="review-section">
            <h3>Casting Schedule</h3>
            <div id="review-casting-schedule"></div>
        </div>
    </div>
    <div id="casting-config-container" class="card">
       <h2 style="border-bottom: 2px solid var(--accent-primary); padding-bottom: 10px; margin-bottom: 20px;">Form Out Build Details</h2>
       <p>Define constraints for new forms and input any pre-existing forms you have available. This information will be used to optimize the casting schedule.</p>
       
       <div class="input-option">
           <h3>Optimization Settings</h3>
           <div class="paste-area">
               <label for="use-filler-panel">
                   <input type="checkbox" id="use-filler-panel" checked>
                   <strong>Use Filler Panel</strong> (Enable/disable filler panels logic in casting optimization)
               </label>
           </div>
           <div class="paste-area">
               <label for="reusable-forms">
                   <input type="checkbox" id="reusable-forms" checked>
                   <strong>Reusable Forms</strong> (Enable/disable form storage logic in casting optimization)
               </label>
           </div>
       </div>
       
       <div class="input-option">
           <h3>Constraints (Optional)</h3>
           <p>Set a maximum length and/or width for newly created forms. This can be useful to match available material sizes.</p>
           <div class="paste-area">
               <label for="max-length-input"><strong>Max Form Length (inches)</strong></label>
               <input type="number" id="max-length-input" placeholder="e.g., 240">
           </div>
           <div class="paste-area">
               <label for="max-width-input"><strong>Max Form Width (inches)</strong></label>
               <input type="number" id="max-width-input" placeholder="e.g., 96">
           </div>
       </div>

       <div class="input-option">
           <h3>Pre-existing Forms (Optional)</h3>
           <p>Enter the dimensions and quantity of pre-existing forms available.</p>
           <div id="pre-existing-forms-container-config">
               <div class="form-row">
                   <span>Form 1</span>
                   <input type="number" placeholder="Width" class="pre-existing-width">
                   <input type="number" placeholder="Length" class="pre-existing-length">
                   <input type="number" placeholder="Quantity" class="pre-existing-qty" value="1">
               </div>
           </div>
           <button id="add-form-row-config" class="btn-secondary">+</button>
       </div>

       <div class="config-actions" style="margin-top: 20px; display: flex; justify-content: space-between; align-items: center;">
            <button id="back-to-review-from-config" class="btn-secondary">Back to Review</button>
            <button id="confirm-config-generate" class="btn-success">Confirm and Generate Schedule</button>
       </div>
    </div>
    <div id="output" class="card" style="display: none;">
        <h2>Casting Schedule</h2>
        <p>This schedule outlines the optimal use of forms for each casting day, minimizing waste and new form creation.</p>
        <p>Please upload an Excel file and click "Generate Schedule".</p>
    </div>
<div id="sticker-settings-container" class="card">
        <h2>Tracking Tickets</h2>
        <p>Configure the layout settings for your sticker sheets to ensure accurate printing. These stickers provide essential panel information for tracking.</p>
        <h3 style="margin-top: 15px;">Sticker Sheet Layout Settings</h3>
        <p>Adjust the layout to match your sticker paper. The default values are for a standard 30-label sheet (e.g., Avery 5160 / Sheet-Labels SL100).</p>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
            <div class="paste-area">
                <label for="sticker-width">Sticker Width (inches)</label>
                <input type="number" id="sticker-width" value="2.625" step="0.001">
            </div>
            <div class="paste-area">
                <label for="sticker-height">Sticker Height (inches)</label>
                <input type="number" id="sticker-height" value="1" step="0.001">
            </div>
            <div class="paste-area">
                <label for="sticker-cols">Columns per Sheet</label>
                <input type="number" id="sticker-cols" value="3" step="1">
            </div>
            <div class="paste-area">
                <label for="sticker-rows">Rows per Sheet</label>
                <input type="number" id="sticker-rows" value="10" step="1">
            </div>
            <div class="paste-area">
                <label for="sheet-margin-top">Top/Bottom Margin (inches)</label>
                <input type="number" id="sheet-margin-top" value="0.5" step="0.001">
            </div>
            <div class="paste-area">
                <label for="sheet-margin-left">Left/Right Margin (inches)</label>
                <input type="number" id="sheet-margin-left" value="0.1875" step="0.001">
            </div>
            <div class="paste-area">
                <label for="gap-vertical">Vertical Gap (inches)</label>
                <input type="number" id="gap-vertical" value="0" step="0.001">
            </div>
            <div class="paste-area">
                <label for="gap-horizontal">Horizontal Gap (inches)</label>
                <input type="number" id="gap-horizontal" value="0.15625" step="0.001">
            </div>
        </div>
        <div style="margin-top: 20px;">
            <button id="confirm-generate-stickers" class="btn-success">Generate & View Stickers</button>
            <button id="cancel-sticker-generation" class="btn-secondary">Cancel</button>
        </div>
    </div>
    <div id="sticker-sheet-container" class="card"></div>
    <div id="tracking-sheet-container" class="card" style="display: none;"></div>
    <div id="casting-layout-container" class="card" style="display: none;">
        <h2>Casting Layout Visualization</h2>
        <p>Interactively place, move, and rotate forms for each cast. Save and load your layouts. <strong>Click and drag</strong> to move a form. <strong>Hold 'R' and drag</strong> to rotate.</p>
        <div id="layout-controls">
            <div class="control-row">
                <!-- Cast selector removed to show all layouts at once -->
                <div>
                    <label for="casting-area-selector">Casting Area:</label>
                    <select id="casting-area-selector">
                        <option value="presetA" selected>Preset A</option>
                        <option value="presetB">Preset B</option>
                    </select>
                </div>
                <div class="panel-dims" style="display: none;">
                    <label>Panel Dimensions (in):</label>
                    <input type="number" id="panel-length-input" placeholder="Length">
                    <input type="number" id="panel-width-input" placeholder="Width">
                    <button id="update-panel-btn" class="btn-secondary">Update Panel</button>
                </div>
            </div>
            <div class="control-row">
                <div style="display: flex; gap: 0.5rem;">
                    <button id="save-layout-btn" class="btn-secondary">Save Layout</button>
                    <button id="load-layout-btn" class="btn-secondary">Load Layout</button>
                    <button id="reset-layout-btn" class="btn-secondary">Reset Layout</button>
                    <button id="print-layout-btn" class="btn-primary">Print Layout</button>
                </div>
            </div>
        </div>
        <div id="layouts-wrapper">
            <!-- Casting layouts will be dynamically inserted here -->
        </div>
        <div id="form-info-box"></div>
    </div>

    <div id="printable-layout-container" style="display: none;"></div>

    <!-- ================================================================================= -->
    <!-- SCRIPT LOGIC -->
    <!-- All application logic is contained within this single script tag. -->
    <!-- ================================================================================= -->
    <!-- ================================================================================= -->
    <!-- IMPORTANT: HOW TO RUN THIS FILE LOCALLY -->
    <!-- ================================================================================= -->
    <!--
        **Problem:** You may see a "failed to fetch" or "CORS" error when trying to load
        data from a Google Sheet URL. This is a security feature in all modern web browsers.
        When you open this HTML file directly from your computer (e.g., file:///...),
        the browser blocks it from fetching data from the internet.

        **Solution:** You must serve this file from a simple local web server. This is
        easy to do and is the standard way to develop web applications.

        --- INSTRUCTIONS ---
        1. Open a terminal or command prompt in the same folder as this HTML file.
           (In VS Code, you can go to Terminal > New Terminal).

        2. Check if you have Python installed by typing:
           python --version
        
        3. If Python is installed, run ONE of the following commands:
           - For Python 3.x:  python -m http.server 8000
           - For Python 2.x:  python -m SimpleHTTPServer 8000

        4. After running the command, open your web browser and go to this address:
           http://localhost:8000

        Your application should now load correctly and be able to fetch data from
        Google Sheets without any "failed to fetch" errors.
    -->
    <script>
        // =================================================================================
        // MODULE: GOOGLE DRIVE & SHEETS API INTEGRATION (OAUTH 2.0 METHOD)
        // =================================================================================
        // IMPORTANT: SETUP INSTRUCTIONS FOR OAUTH 2.0
        // This method is for secure access to a user's private files.
        // 1. Go to https://console.cloud.google.com/ and create a new project.
        // 2. In the sidebar, go to "APIs & Services" > "Library".
        // 3. Search for "Google Drive API" and enable it.
        // 4. In the sidebar, go to "APIs & Services" > "OAuth consent screen". Configure it for "External" users, add your app name, user support email, and developer contact.
        // 5. In the sidebar, go to "APIs & Services" > "Credentials".
        // 6. Click "+ CREATE CREDENTIALS" and select "OAuth 2.0 Client ID".
        // 7. Choose "Web application" as the application type.
        // 8. Under "Authorized JavaScript origins", add the URL where you are hosting this file (e.g., http://localhost:8000).
        // 9. Copy the generated "Client ID" and paste it below.
        // =================================================================================
        const CLIENT_ID = 'YOUR_CLIENT_ID_HERE'; // <-- PASTE YOUR OAUTH 2.0 CLIENT ID HERE
        const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
        // Scopes control the level of access. `drive.readonly` is for viewing files.
        // For future write capabilities, you would add `https://www.googleapis.com/auth/drive.file`.
        const SCOPES = 'https://www.googleapis.com/auth/drive.readonly';

        let tokenClient;
        let gapiInited = false;
        let gisInited = false;

        const authorizeButton = document.getElementById('authorize-button');
        const signoutButton = document.getElementById('signout-button');
        const driveControls = document.getElementById('drive-controls'); // This div is now always visible
        const folderUrlInput = document.getElementById('google-drive-folder-url-input');
        const getSheetsButton = document.getElementById('get-sheets-button');

        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({ discoveryDocs: DISCOVERY_DOCS });
            gapiInited = true;
            trySilentSignIn();
        }

        function gisLoaded() {
            if (!CLIENT_ID || CLIENT_ID === 'YOUR_CLIENT_ID_HERE') {
                const message = 'OAuth Client ID is not configured. Please follow the setup instructions in the index.html file.';
                alert(message);
                authorizeButton.textContent = 'Client ID Missing';
                authorizeButton.style.display = 'block';
                console.error(message);
                return;
            }
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: (tokenResponse) => {
                    // This single callback handles all token responses, from both
                    // silent and interactive sign-in attempts.
                    if (tokenResponse && tokenResponse.access_token) {
                        gapi.client.setToken(tokenResponse);
                        updateSigninStatus(true);
                    } else {
                        // This case is hit when silent sign-in fails, meaning the user
                        // has not granted consent or is signed out. We now show the button.
                        updateSigninStatus(false);
                    }
                },
            });
            gisInited = true;
            trySilentSignIn();
        }

        function trySilentSignIn() {
            // This function is called by both library loaders. The conditional check
            // ensures it only runs once, after both are ready.
            if (gapiInited && gisInited) {
                // Attempt to get a token silently.
                tokenClient.requestAccessToken({prompt: 'none'});
            }
        }

        function updateSigninStatus(isSignedIn) {
            if (isSignedIn) {
                folderUrlInput.disabled = false;
                getSheetsButton.disabled = false;
                folderUrlInput.placeholder = 'e.g., https://drive.google.com/drive/folders/YOUR_FOLDER_ID';
                signoutButton.style.display = 'block';
                authorizeButton.style.display = 'none';
            } else {
                folderUrlInput.disabled = true;
                getSheetsButton.disabled = true;
                folderUrlInput.value = '';
                folderUrlInput.placeholder = 'Sign in to enable';
                document.getElementById('sheet-list-container').style.display = 'none';
                signoutButton.style.display = 'none';
                authorizeButton.style.display = 'block'; // Show the sign-in button
            }
        }

        function handleAuthClick() {
            // When the user clicks the sign-in button, request a token with consent.
            if (gisInited) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                // Revoke the token and update the UI.
                google.accounts.oauth2.revoke(token.access_token, () => {
                    gapi.client.setToken('');
                    updateSigninStatus(false);
                });
            }
        }

        function getFolderIdFromUrl(url) {
            const match = url.match(/folders\/([a-zA-Z0-9_-]+)/);
            return match ? match[1] : null;
        }

        async function listSheetsInFolder() {
            const folderUrl = document.getElementById('google-drive-folder-url-input').value;
            if (!folderUrl) {
                alert('Please enter a Google Drive folder URL.');
                return;
            }

            const folderId = getFolderIdFromUrl(folderUrl);
            if (!folderId) {
                alert('Invalid Google Drive folder URL. Please ensure it contains "/folders/".');
                return;
            }

            if (gapi.client.getToken() === null) {
                alert('Please sign in first to access Google Drive.');
                return;
            }

            let response;
            try {
                response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and mimeType='application/vnd.google-apps.spreadsheet' and trashed=false`,
                    fields: 'files(id, name)',
                });
            } catch (err) {
                console.error("API call error:", err);
                alert('An error occurred while fetching files. Ensure the folder is shared with you and the URL is correct.');
                return;
            }

            const files = response.result.files;
            const sheetListDiv = document.getElementById('sheet-list');
            const sheetListContainer = document.getElementById('sheet-list-container');
            const loadSelectedButton = document.getElementById('load-selected-sheet');
            sheetListDiv.innerHTML = ''; // Clear previous list

            if (!files || files.length == 0) {
                sheetListDiv.innerHTML = '<p>No Google Sheets found in this folder.</p>';
                sheetListContainer.style.display = 'block';
                loadSelectedButton.disabled = true;
                return;
            }

            files.forEach(file => {
                const radioLabel = document.createElement('label');
                radioLabel.style.display = 'block';
                radioLabel.style.padding = '0.5rem';
                radioLabel.style.cursor = 'pointer';
                radioLabel.innerHTML = `
                    <input type="radio" name="sheet-selection" value="${file.id}">
                    ${file.name}
                `;
                sheetListDiv.appendChild(radioLabel);
            });
            
            sheetListDiv.addEventListener('change', () => {
                loadSelectedButton.disabled = false;
            });

            sheetListContainer.style.display = 'block';
        }

        async function loadSelectedSheet() {
            const selected = document.querySelector('input[name="sheet-selection"]:checked');
            if (!selected) {
                alert('Please select a sheet to load.');
                return;
            }
            const spreadsheetId = selected.value;
            await loadDataFromGoogleSheetById(spreadsheetId);
        }

        /**
         * Fetches data from a public Google Sheet using the gviz CSV export URL.
         * This method does not require OAuth authentication.
         */
        async function loadDataFromGoogleSheetById(spreadsheetId) {
            if (!spreadsheetId) {
                alert('No spreadsheet ID provided.');
                return;
            }

            const sheetNames = ["Project Information", "Panel Legend", "Casting Schedule"];
            const sheetData = {};
            
            const loadButton = document.getElementById('load-selected-sheet');
            const originalButtonText = loadButton.textContent;
            loadButton.textContent = 'Loading...';
            loadButton.disabled = true;

            try {
                for (const sheetName of sheetNames) {
                    const encodedSheetName = encodeURIComponent(sheetName);
                    // Use a CORS proxy to bypass browser security restrictions.
                    const targetUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/gviz/tq?tqx=out:csv&sheet=${encodedSheetName}`;
                    const csvUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`;
                    
                    console.log(`Fetching from URL: ${csvUrl}`);

                    const response = await fetch(csvUrl);
                    const responseText = await response.text();

                    if (!response.ok || responseText.includes('"status":"error"')) {
                         throw new Error(`Failed to fetch sheet: "${sheetName}". Please ensure the folder and sheet are public.`);
                    }
                    
                    if (responseText.trim().startsWith('<')) {
                        throw new Error(`Received an unexpected HTML response for "${sheetName}". This usually indicates a permission issue.`);
                    }

                    const parsedCsv = parseCsv(responseText);
                    sheetData[sheetName] = parsedCsv;
                    appState.rawSheetData[sheetName] = responseText;
                    console.log(`Successfully parsed "${sheetName}":`, parsedCsv);
                }

                const parsedData = transformCsvDataToAppState(sheetData);
                processData(parsedData);

            } catch (error) {
                console.error('Error during Google Sheet data load:', error);
                alert(`A critical error occurred: ${error.message}`);
            } finally {
                loadButton.textContent = originalButtonText;
                // The button will be re-enabled if the user selects another sheet.
            }
        }

        // =================================================================================
        // MODULE: APP STATE & INITIALIZATION
        // =================================================================================
        // Global variable to track the number of pre-existing form rows in the UI.
        let formRowCount = 1;

        // Centralized object to hold the application's state, including parsed data.
        const appState = {
            panelLegend: null,      // Object containing details for each panel type.
            castingSchedule: null,  // Array of objects, where each object represents a day's cast.
            projectInfo: null,      // Object with project metadata (e.g., Project Name, Address).
            projectName: '',         // The name of the project, extracted for easy access.
            finalFormInventory: [],  // Holds the final state of the form inventory after scheduling.
            rawSheetData: {}        // Holds the raw text response for debugging.
        };
        
        // Holds the state for the interactive casting layout, including positions and rotations.
        const castingAreas = {
            presetA: {
                tables: [
                    { length: 65 * 12, width: 5 * 12 }, // 780x60
                    { length: 45 * 12, width: 5 * 12 }  // 540x60
                ],
                // Combined view for the canvas - updated for vertical stacking
                totalLength: Math.max(65 * 12, 45 * 12), // 780
                totalWidth: (5 * 12) + (5 * 12) + 40 // 120 + 40 for increased spacing
            },
            presetB: {
                tables: Array(8).fill({ length: 10 * 12, width: 5 * 12 }), // Rotated: 8 tables of 120x60
                // 2x4 grid layout
                totalLength: (4 * (10 * 12)) + (3 * 10), // 510 inches
                totalWidth: (2 * (5 * 12)) + (1 * 10)  // 130 inches
            }
        };

        const layoutState = {
            layouts: {}, // Keyed by castIndex
            activeCastIndex: 0,
            selectedFormId: null,
            dragStart: { x: 0, y: 0 },
            isDragging: false,
            isRotating: false,
            rKeyDown: false,
            panelDimensions: { length: 0, width: 0 },
            selectedCastingArea: 'presetA' // Default to Preset A
        };

        // Fallback data used if the uploaded file doesn't contain a casting schedule.
        // This allows the application to function even with incomplete input data.
        const fallbackCastingSchedule = [
            { "P21": 4, "P35": 4, "P41": 4 }, { "P21": 4, "P35": 4, "P41": 4 }, { "P6": 3, "P14": 3, "P21": 1, "P35": 1, "P41": 3, "P42": 3 }, { "P2": 1, "P4": 2, "P10": 1, "P12": 2, "P18": 1, "P21": 3, "P28": 1, "P35": 3 }, { "P7": 3, "P15": 3, "P22": 3, "P30": 3, "P31": 1 }, { "P7": 2, "P15": 2, "P22": 2, "P27": 1, "P30": 2, "P31": 1, "P49": 1, "P50": 1, "P51": 1 }, { "P7": 3, "P15": 3, "P22": 3, "P23": 1, "P30": 1, "P36": 1, "P43": 1 }, { "P6": 2, "P14": 2, "P23": 2, "P30": 1, "P36": 2, "P42": 2, "P43": 2 }, { "P6": 3, "P7": 1, "P14": 2, "P15": 1, "P16": 1, "P22": 1, "P26": 1, "P40": 1, "P42": 2, "P48": 1 }, { "P10": 1, "P14": 4, "P20": 1, "P29": 1, "P42": 2, "P52": 2 }, { "P3": 1, "P13": 1, "P23": 3, "P25": 1, "P26": 2, "P36": 3, "P43": 2, "P52": 2 }, { "P23": 3, "P33": 2, "P36": 3, "P37": 2, "P43": 2, "P44": 1 }, { "P1": 1, "P5": 1, "P9": 1, "P11": 1, "P17": 1, "P32": 1, "P33": 1, "P34": 1, "P37": 1, "P38": 1, "P39": 1, "P44": 2, "P45": 1, "P46": 1 }, { "P11": 2, "P15": 2, "P36": 3, "P38": 2, "P47": 3 }, { "P15": 6, "P36": 6 }, { "P15": 4, "P36": 3 }
        ];

        // =================================================================================
        // MODULE: DATA PARSING
        // =================================================================================

        /**
         * Parses CSV text into an array of objects, using the first row as headers.
         * Handles basic CSV format with comma delimiters and optional double quotes.
         * @param {string} csvString The CSV content as a string.
         * @returns {Array<object>} An array of objects, where each object represents a row.
         */
        function parseCsv(csvString) {
            const lines = csvString.trim().split('\n');
            if (lines.length === 0) return [];

            // Simple regex to split by comma, but not if inside double quotes
            const splitRegex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;

            const headers = lines[0].split(splitRegex).map(h => h.trim().replace(/^"|"$/g, ''));
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue; // Skip empty lines

                const values = line.split(splitRegex).map(v => v.trim().replace(/^"|"$/g, ''));
                if (values.length === headers.length) {
                    const rowObject = {};
                    headers.forEach((header, index) => {
                        rowObject[header] = values[index];
                    });
                    data.push(rowObject);
                } else {
                    console.warn(`Skipping malformed CSV row: "${line}" (Expected ${headers.length} columns, got ${values.length})`);
                }
            }
            return data;
        }

        /**
         * Transforms parsed CSV data from Google Sheets into the application's expected state format.
         * @param {object} sheetData An object where keys are sheet names and values are parsed CSV data (array of objects).
         * @returns {{panelLegend: object, castingSchedule: object[], projectInfo: object}} Structured data for the appState.
         */
        function transformCsvDataToAppState(sheetData) {
            const panelLegend = {};
            if (sheetData["Panel Legend"]) {
                sheetData["Panel Legend"].forEach(row => {
                    if (row["Panel ID"]) {
                        panelLegend[row["Panel ID"]] = {
                            length: row["Length"] || '',
                            width: row["Width"] || '',
                            thickness: row["Thickness"] || '',
                            castingType: row["Casting Type"] || '',
                            finish: row["Finish"] || '',
                            color: row["Color"] || '',
                            comments: row["Comments"] || ''
                        };
                    }
                });
            }

            const castingSchedule = [];
            if (sheetData["Casting Schedule"] && sheetData["Casting Schedule"].length > 0) {
                const scheduleHeaders = Object.keys(sheetData["Casting Schedule"][0]);
                for (let i = 0; i < sheetData["Casting Schedule"].length; i++) {
                    const row = sheetData["Casting Schedule"][i];
                    const cast = {};
                    for (const header of scheduleHeaders) {
                        if (header !== "Day" && row[header] && !isNaN(parseInt(row[header], 10))) {
                            cast[header] = parseInt(row[header], 10);
                        }
                    }
                    if (Object.keys(cast).length > 0) {
                        castingSchedule.push(cast);
                    }
                }
            }
            if (castingSchedule.length === 0) {
                console.log("Casting schedule not found or empty in the file, using fallback schedule.");
                castingSchedule = fallbackCastingSchedule;
            }

            const projectInfo = {};
            if (sheetData["Project Information"]) {
                sheetData["Project Information"].forEach(row => {
                    // Assuming Project Information is key-value pairs, e.g., "Key", "Value" columns
                    if (row["Key"] && row["Value"]) {
                        projectInfo[row["Key"]] = row["Value"];
                    }
                });
            }

            return { panelLegend, castingSchedule, projectInfo };
        }

        /**
         * Parses a dimension string (e.g., "10' 5 1/2\"") into a single numerical value in inches.
         * Handles feet, inches, and fractional inches.
         * @param {string} dimStr The dimension string to parse.
         * @returns {number} The total dimension in inches. Returns 0 if the input is not a string.
         */
        function parseDim(dimStr) {
            if (typeof dimStr !== 'string') return 0;
            let total = 0;
            const parts = dimStr.replace(/"/g, '').trim().split(' ');
            parts.forEach(part => {
                if (part.includes('/')) {
                    const fraction = part.split('/');
                    total += parseInt(fraction[0], 10) / parseInt(fraction[1], 10);
                } else if (part) {
                    total += parseInt(part, 10);
                }
            });
            return total;
        }

        /**
         * Parses data from an uploaded Excel workbook. It looks for specific sheet names
         * ("Panel Legend", "Casting Schedule", "Project Information") and extracts the
         * relevant data into structured JavaScript objects.
         * @param {object} workbook The workbook object from the xlsx library.
         * @returns {{panelLegend: object, castingSchedule: object[], projectInfo: object}} An object containing the parsed data.
         * @throws {Error} If the "Panel Legend" sheet is not found.
         */
        function parseExcelData(workbook) {
           const legendSheetName = workbook.SheetNames.find(name => name.toLowerCase().includes('panel legend'));
           const scheduleSheetName = workbook.SheetNames.find(name => name.toLowerCase().includes('casting schedule'));
           const projectInfoSheetName = workbook.SheetNames.find(name => name.toLowerCase().includes('project information'));
           if (!legendSheetName) {
               throw new Error('Could not find a sheet named "Panel Legend" in the Excel file.');
           }
           // --- Parse Project Information (New Flexible Method) ---
           let projectInfo = null;
           if (projectInfoSheetName) {
               projectInfo = {};
               const projectInfoSheet = workbook.Sheets[projectInfoSheetName];
               const projectInfoJson = XLSX.utils.sheet_to_json(projectInfoSheet, { header: 1, defval: "" });
               let lastKey = null;
               projectInfoJson.forEach(row => {
                   if (row && row.length > 0) {
                       const key = String(row[0]).trim().replace(/:$/, '').trim();
                       const value = row.slice(1).map(v => String(v || '').trim()).join(' ');
                       if (key) { // We have a new key
                           projectInfo[key] = value;
                           lastKey = key;
                       } else if (lastKey && value) { // No new key, but we have a value and a previous key
                           // This is a continuation of the previous line, e.g., multi-line address
                           projectInfo[lastKey] += '\n' + value;
                       }
                   }
               });
           }
           // --- Parse Panel Legend (New Robust Method) ---
           const panelLegendSheet = workbook.Sheets[legendSheetName];
           const panelLegendJson = XLSX.utils.sheet_to_json(panelLegendSheet, { header: 1, defval: "" });
           const panelLegend = {};

           if (panelLegendJson.length < 1) {
               throw new Error('The "Panel Legend" sheet is empty or could not be read.');
           }

           const headers = panelLegendJson[0].map(h => String(h || '').trim().toLowerCase());
           const panelIdColIndex = headers.indexOf('panel id');

           if (panelIdColIndex === -1) {
               throw new Error('Could not find a "Panel ID" column in the "Panel Legend" sheet. Please ensure the column header is named "Panel ID".');
           }

           // Create a map of lowercase headers to their original index
           const headerMap = {};
           panelLegendJson[0].forEach((h, i) => {
               headerMap[String(h || '').trim().toLowerCase()] = i;
           });

           const keyToHeaderMap = {
               length: 'length',
               width: 'width',
               thickness: 'thickness',
               castingType: 'casting type',
               finish: 'finish',
               color: 'color',
               comments: 'comments'
           };

           for (let i = 1; i < panelLegendJson.length; i++) {
               const row = panelLegendJson[i];
               if (!row || row.length === 0) continue; // Skip empty rows

               const panelId = String(row[panelIdColIndex] || '').trim();
               if (panelId) {
                   panelLegend[panelId] = {};
                   for (const key in keyToHeaderMap) {
                       const headerName = keyToHeaderMap[key];
                       const colIndex = headerMap[headerName];
                       if (colIndex !== undefined) {
                           panelLegend[panelId][key] = String(row[colIndex] || '').trim();
                       } else {
                           panelLegend[panelId][key] = ''; // Default to empty string if column not found
                       }
                   }
               }
           }
           // --- Parse Casting Schedule ---
           let castingSchedule = [];
           if (scheduleSheetName) {
               const scheduleSheet = workbook.Sheets[scheduleSheetName];
               const scheduleJson = XLSX.utils.sheet_to_json(scheduleSheet, { header: 1, defval: "" });
               if (scheduleJson.length > 1) {
                   const headers = scheduleJson[0].map(h => String(h).trim());
                   for (let i = 1; i < scheduleJson.length; i++) {
                       const row = scheduleJson[i];
                       if (!row || row.length === 0 || row.every(cell => cell === "" || cell === null || cell === undefined)) continue;
                       const cast = {};
                       for (let j = 1; j < headers.length; j++) {
                           const panelId = headers[j];
                           const qtyRaw = row[j];
                           if (panelId && (qtyRaw !== undefined && qtyRaw !== null && qtyRaw !== "")) {
                               const qty = parseInt(String(qtyRaw).trim(), 10);
                               if (!isNaN(qty) && qty > 0) {
                                   cast[panelId] = qty;
                               }
                           }
                       }
                       if (Object.keys(cast).length > 0) {
                           castingSchedule.push(cast);
                       }
                   }
               }
           }
           if (castingSchedule.length === 0) {
               console.log("Casting schedule not found or empty in the file, using fallback schedule.");
               castingSchedule = fallbackCastingSchedule;
           }
           return { panelLegend, castingSchedule, projectInfo };
        }


        /**
         * Processes the parsed data from `parseExcelData` or `loadDataFromGoogleSheet`. It validates the essential
         * `panelLegend`, stores all data in the global `appState`, and then calls
         * `displayReviewData` to show the parsed information to the user for confirmation.
         * @param {{panelLegend: object, castingSchedule: object[], projectInfo: object}} data The parsed data object.
         */
        function processData({ panelLegend, castingSchedule, projectInfo }) {
            if (!panelLegend || Object.keys(panelLegend).length === 0) {
                const rawLegendData = appState.rawSheetData ? (appState.rawSheetData['Panel Legend'] || 'Sheet not found or empty.') : 'N/A';
                const friendlyMessage = `Could not parse the "Panel Legend".

This usually happens for one of these reasons:
1.  The Google Sheet is not shared publicly with "Anyone with the link".
2.  The sheet name in your Google Sheet is not exactly "Panel Legend" (it's case-sensitive).
3.  The "Panel Legend" sheet does not contain a column header named exactly "Panel ID".

Please verify these points and try again.

--------------------------------------------------
Raw Data Received for "Panel Legend" (first 500 chars):
--------------------------------------------------
${String(rawLegendData).substring(0, 500)}...
`;
                alert(friendlyMessage);
                console.error("Panel Legend parsing failed. Raw data:", rawLegendData);
                return;
            }

            appState.panelLegend = panelLegend;
            appState.castingSchedule = castingSchedule;
            appState.projectInfo = projectInfo;
            appState.projectName = (projectInfo && projectInfo['Project Name']) || 'N/A';
            displayReviewData();
        }


        // =================================================================================
        // MODULE: CORE SCHEDULING LOGIC
        // The main algorithm for optimizing form reuse.
        // =================================================================================

        /**
         * Analyzes all future panel requirements to determine the most efficient size for a new form.
         * The goal is to find a form size that can accommodate the maximum number of future panels,
         * thereby minimizing the number of new forms that need to be built.
         * It prioritizes covering the most panels, then the smallest form area, and finally the least wasted space (filler area).
         * @param {object} panelLegend The master list of panel specifications.
         * @param {string[]} allPanels A flat array of all panel IDs that need to be cast from this point forward.
         * @param {object} constraints Contains `maxLength` and `maxWidth` to restrict form dimensions.
         * @param {object} minimums Contains `minLength` and `minWidth` required for the current panel.
         * @param {boolean} useFillerPanel A flag to determine the optimization strategy. If true, it optimizes for reusability with fillers. If false, it prioritizes exact matches.
         * @returns {{optimalLength: number, optimalWidth: number}} The calculated optimal dimensions for a new form.
         */
        function findOptimalFormSize(panelLegend, allPanels, constraints = {}, minimums = {}, useFillerPanel = true) {
            const { maxLength = Infinity, maxWidth = Infinity } = constraints;
            const { minLength = 0, minWidth = 0 } = minimums;
            if (allPanels.length === 0) {
                const optimalLength = Math.min(minLength, maxLength);
                const optimalWidth = Math.min(minWidth, maxWidth);
                return { optimalLength: optimalLength, optimalWidth: Math.max(optimalWidth, 50) };
            }
            const panelDimensions = allPanels.map(panelId => {
                const details = panelLegend[panelId];
                if (!details) return null;
                return {
                    id: panelId,
                    length: parseDim(details.length),
                    width: parseDim(details.width)
                };
            }).filter(p => p !== null);
            if (panelDimensions.length === 0) {
                const optimalLength = Math.min(minLength, maxLength);
                const optimalWidth = Math.min(minWidth, maxWidth);
                return { optimalLength: optimalLength, optimalWidth: Math.max(optimalWidth, 50) };
            }
            const uniqueLengths = [...new Set(panelDimensions.map(p => p.length))]
                .filter(l => l <= maxLength)
                .sort((a, b) => a - b);
            const uniqueWidths = [...new Set(panelDimensions.map(p => p.width))]
                .filter(w => w <= maxWidth)
                .sort((a, b) => a - b);
            let bestCombination = {
                length: 0,
                width: 0,
                coveredPanels: -1,
                area: Infinity,
                fillerArea: Infinity // Keep for calculation, but its influence will be conditional
            };
            for (const testLength of uniqueLengths) {
                for (const testWidth of uniqueWidths) {
                    if (testLength < minLength || testWidth < minWidth) continue;
                    const fittingPanels = panelDimensions.filter(p => p.length <= testLength && p.width <= testWidth);
                    const coveredPanels = fittingPanels.length;
                    if (coveredPanels === 0) continue;
                    const area = testLength * testWidth;
                    const totalPanelArea = fittingPanels.reduce((sum, p) => sum + (p.length * p.width), 0);
                    const fillerArea = (coveredPanels * area) - totalPanelArea;

                    if (useFillerPanel) {
                        if (coveredPanels > bestCombination.coveredPanels) {
                            bestCombination = { length: testLength, width: testWidth, coveredPanels, area, fillerArea };
                        } else if (coveredPanels === bestCombination.coveredPanels) {
                            if (area < bestCombination.area) {
                                bestCombination = { length: testLength, width: testWidth, coveredPanels, area, fillerArea };
                            } else if (area === bestCombination.area) {
                                if (fillerArea < bestCombination.fillerArea) {
                                    bestCombination = { length: testLength, width: testWidth, coveredPanels, area, fillerArea };
                                }
                            }
                        }
                    } else { // If not using filler panels, prioritize smallest area that fits
                        if (coveredPanels > bestCombination.coveredPanels) {
                            bestCombination = { length: testLength, width: testWidth, coveredPanels, area, fillerArea: Infinity }; // fillerArea is irrelevant
                        } else if (coveredPanels === bestCombination.coveredPanels) {
                            if (area < bestCombination.area) {
                                bestCombination = { length: testLength, width: testWidth, coveredPanels, area, fillerArea: Infinity };
                            }
                        }
                    }
                }
            }
            let finalLength = bestCombination.length;
            let finalWidth = bestCombination.width;
            if (finalLength === 0) {
                finalLength = Math.min(minLength, maxLength);
                finalWidth = Math.min(minWidth, maxWidth);
            }
            console.log('Optimal form size calculated:', { length: finalLength, width: finalWidth });
            return {
                optimalLength: finalLength,
                optimalWidth: Math.max(finalWidth, 50)
            };
        }

        /**
         * The core function of the application. It orchestrates the entire scheduling process.
         * It iterates through each cast (day) in the `castingSchedule`, determines the actions
         * required (reuse existing form, build new form), and tracks the inventory of forms
         * from one cast to the next. The final output is a detailed HTML table for each cast.
         * @param {object} panelLegend The master list of panel specifications.
         * @param {object[]} castingSchedule The list of casts, with each cast being an object of panel IDs and quantities.
         */
        function generateSchedule(panelLegend, castingSchedule) {
            const maxLengthInput = document.getElementById('max-length-input').value;
            const maxWidthInput = document.getElementById('max-width-input').value;
            const useFillerPanel = document.getElementById('use-filler-panel').checked;
            const reusableForms = document.getElementById('reusable-forms').checked;

            const constraints = {
                maxLength: maxLengthInput ? parseInt(maxLengthInput, 10) : Infinity,
                maxWidth: maxWidthInput ? parseInt(maxWidthInput, 10) : Infinity,
            };
            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = '';
            document.getElementById('print-schedule-button').disabled = true;
            document.getElementById('print-note').style.display = 'none';
            // Initialize the form inventory. This will hold all available forms (both pre-existing and newly built).
            let formInventory = [];
            let nextFormId = 1; // Counter for assigning unique IDs to forms.

            // Load any user-defined pre-existing forms into the inventory.
            const formRows = document.querySelectorAll('#pre-existing-forms-container-config .form-row');
            formRows.forEach(row => {
                const quantity = parseInt(qtyInput.value, 10);
                if (!isNaN(width) && width > 0 && !isNaN(length) && length > 0 && !isNaN(quantity) && quantity > 0) {
                    for (let i = 0; i < quantity; i++) {
                        formInventory.push({
                            id: nextFormId++,
                            formLength: length,
                            initialWidth: width,
                            lastUsedFor: 'Pre-existing', // Special status for initial forms
                            lastUsedPanelWidth: width,
                            lastUsedPanelLengthStr: `${length}"`,
                            lastUsedPanelWidthStr: `${width}"`,
                        });
                    }
                }
            });

            // Begin building the HTML output for the schedule.
            let fullOutput = `<h2>Casting Schedule</h2>
            <p>This schedule outlines the optimal use of forms for each casting day, minimizing waste and new form creation.</p>`;

            // --- MAIN CASTING LOOP ---
            // Iterate through each day's cast in the schedule.
            castingSchedule.forEach((cast, castIndex) => {
                const castNumber = castIndex + 1;
                let availableForms = [...formInventory]; // Forms available at the start of this cast.
                const usedThisCast = []; // Forms that are used or built during this cast.
                const productionActions = []; // Log of actions for the output table (e.g., "Reuse", "New").
                const storeActions = []; // Log of forms being stored for the next cast.

                // Create a flat list of all individual panels required for this cast.
                const requiredPanels = cast;
                const requiredPanelsList = [];
                for (const panelId in requiredPanels) {
                    if (!panelLegend[panelId]) {
                        console.warn(`Panel ID ${panelId} not found in legend. Skipping.`);
                        continue;
                    }
                    for (let i = 0; i < requiredPanels[panelId]; i++) {
                        requiredPanelsList.push(panelId);
                    }
                }

                // --- PANEL PROCESSING LOOP ---
                // For each required panel, find or create a suitable form.
                requiredPanelsList.forEach((panelId, panelIndex) => {
                    const panelDetails = panelLegend[panelId];
                    const requiredLength = parseDim(panelDetails.length);
                    const requiredWidth = parseDim(panelDetails.width);
                    let formFoundAndUsed = false;
                    let bestFormToReuse = null;

                    // --- FIND A REUSABLE FORM ---
                    // Filter the available inventory to find forms that are large enough for the current panel.
                    const suitableForms = availableForms.filter(f => f.formLength >= requiredLength && f.initialWidth >= requiredWidth);

                    if (suitableForms.length > 0) {
                        // Score each suitable form to find the best fit.
                        // The scoring logic changes based on whether filler panels are allowed.
                        suitableForms.forEach(f => {
                            if (useFillerPanel) {
                                // With fillers, the best form is one that is slightly larger than the panel.
                                // We prioritize exact dimension matches heavily, then the smallest waste area.
                                f.score = (f.formLength * f.initialWidth) - (requiredLength * requiredWidth); // Lower score is better (less waste)
                                if (f.formLength === requiredLength && f.initialWidth === requiredWidth) {
                                    f.score = 0; // Exact match is best.
                                } else {
                                    f.score = (f.formLength * f.initialWidth); // Otherwise, just minimize total area.
                                }
                            }
                        });
                        // The form with the lowest score is the best one to reuse.
                        suitableForms.sort((a, b) => a.score - b.score);
                        bestFormToReuse = suitableForms[0];
                    }

                    // --- DECISION: REUSE OR BUILD NEW ---
                    if (bestFormToReuse) {
                        // A suitable form was found in the inventory.
                        const form = bestFormToReuse;
                        let note = '';
                        if (form.lastUsedFor === 'Pre-existing') {
                            note = 'Utilized pre-existing form. ';
                        }
                        if (form.formLength === requiredLength && form.initialWidth === requiredWidth) {
                            note += 'Exact form match; no modification needed.';
                        } else if (useFillerPanel) {
                            if (form.formLength === requiredLength) {
                                note += `Adjust fillers to ${panelDetails.width} width.`;
                            } else if (form.initialWidth === requiredWidth) {
                                note += `Adjust fillers to ${panelDetails.length} length.`;
                            } else {
                                note += `Adjust fillers to ${panelDetails.length} length and ${panelDetails.width} width.`;
                            }
                        } else {
                            note += `Form used for ${panelDetails.length} L x ${panelDetails.width} W.`;
                        }
                        productionActions.push({
                            action: `Reuse (${form.lastUsedFor} -> <strong>${panelId}</strong>)`,
                            qty: 1,
                            dimensions: `${panelDetails.length} L x ${panelDetails.width} W`,
                            notes: note
                        });
                        form.lastUsedFor = panelId;
                        form.lastUsedPanelWidth = requiredWidth;
                        form.lastUsedPanelLengthStr = panelDetails.length;
                        form.lastUsedPanelWidthStr = panelDetails.width;
                        usedThisCast.push(form);
                        availableForms = availableForms.filter(f => f.id !== form.id);
                        formFoundAndUsed = true;
                    }
                    if (!formFoundAndUsed) {
                        // No suitable form was found. We must build a new one.
                        // To do this intelligently, we look at all remaining panels (in this cast and future casts)
                        // to decide on the most optimal dimensions for this new form.
                        const remainingForThisCast = requiredPanelsList.slice(panelIndex);
                        const futureCasts = castingSchedule.slice(castIndex + 1);
                        const futurePanels = [];
                        futureCasts.forEach(futureCast => {
                            for (const pId in futureCast) {
                                for (let i = 0; i < futureCast[pId]; i++) {
                                    futurePanels.push(pId);
                                }
                            }
                        });
                        const allRemainingPanels = remainingForThisCast.concat(futurePanels);

                        // Call the optimizer function to get the best dimensions.
                        const { optimalLength, optimalWidth } = findOptimalFormSize(
                            panelLegend,
                            allRemainingPanels,
                            constraints,
                            { minLength: requiredLength, minWidth: requiredWidth }, // Must be at least as big as the current panel
                            useFillerPanel
                        );

                        const newFormLength = optimalLength;
                        const newFormWidth = optimalWidth;

                        // Create the new form object.
                        const newForm = {
                            id: nextFormId++,
                            formLength: newFormLength,
                            initialWidth: newFormWidth,
                            lastUsedFor: panelId, // Immediately used for the current panel
                            lastUsedPanelWidth: requiredWidth,
                            lastUsedPanelLengthStr: panelDetails.length,
                            lastUsedPanelWidthStr: panelDetails.width,
                        };

                        // Add the new form to the list of forms used in this cast.
                        usedThisCast.push(newForm);

                        // Create a log entry for the output table.
                        let note = `New form built (${newFormLength}" L x ${newFormWidth}" W).`;
                        if (useFillerPanel) {
                            note += ` Set fillers for ${panelDetails.length} L x ${panelDetails.width} W.`;
                        }
                        if (requiredLength > newFormLength || requiredWidth > newFormWidth) {
                            note += ` <strong>WARNING: Panel may not fit. Required: ${requiredLength}"x${requiredWidth}". Form constrained to ${newFormLength}"x${newFormWidth}".</strong>`;
                        }
                        productionActions.push({
                            action: `New (for <strong>${panelId}</strong>)`,
                            qty: 1,
                            dimensions: `${panelDetails.length} L x ${panelDetails.width} W`,
                            notes: note
                        });
                    }
                });

                // --- END OF CAST: UPDATE INVENTORY ---
                // After processing all panels for the cast, update the form inventory for the next day.
                if (reusableForms) {
                    // If forms are reusable, they are carried over. This includes forms that were
                    // used in this cast and those that were available but not used.
                    availableForms.forEach(form => {
                        storeActions.push({
                            action: `Store (Last used for <strong>${form.lastUsedFor}</strong>)`,
                            qty: 1,
                            dimensions: `Form: ${form.lastUsedPanelLengthStr} L x ${form.initialWidth}" W`,
                            notes: "Store form; no modification."
                        });
                    });
                    formInventory = [...usedThisCast, ...availableForms];
                } else {
                    // If forms are not reusable, the inventory is cleared for the next cast.
                    // This ensures new forms are built for subsequent casts as needed.
                    // No "Store" actions are generated, and unused forms from this cast are discarded.
                    formInventory = [];
                }
                fullOutput += `<div class="cast-schedule-print-container">`;
                fullOutput += `<h3>Cast ${castNumber}</h3>`;
                fullOutput += `
                    <table class="schedule-table">
                        <tr>
                            <th>Action / Status Detail</th>
                            <th>Qty</th>
                            <th>Dimensions</th>
                            <th>Modification Notes</th>
                        </tr>
                        <tr><td colspan="4"><strong>--- Forms Put into Production ---</strong></td></tr>
                `;
                const aggregatedActions = {};
                productionActions.forEach(pa => {
                    const key = `${pa.action}|${pa.dimensions}|${pa.notes}`;
                    if (!aggregatedActions[key]) {
                        aggregatedActions[key] = { ...pa, qty: 0 };
                    }
                    aggregatedActions[key].qty += pa.qty;
                });
                for(const key in aggregatedActions) {
                    const action = aggregatedActions[key];
                    fullOutput += `<tr><td>${action.action}</td><td>${action.qty}</td><td>${action.dimensions}</td><td>${action.notes}</td></tr>`;
                }
                if (storeActions.length > 0) {
                    fullOutput += `<tr><td colspan="4"><strong>--- Store Forms ---</strong></td></tr>`;
                    const aggregatedStorage = {};
                    storeActions.forEach(sa => {
                        const key = `${sa.action}|${sa.dimensions}|${sa.notes}`;
                        if (!aggregatedStorage[key]) {
                            aggregatedStorage[key] = { ...sa, qty: 0 };
                        }
                        aggregatedStorage[key].qty += sa.qty;
                    });
                    for(const key in aggregatedStorage) {
                        const action = aggregatedStorage[key];
                        fullOutput += `<tr><td>${action.action}</td><td>${action.qty}</td><td>${action.dimensions}</td><td>${action.notes}</td></tr>`;
                    }
                }
                fullOutput += `</table>`;
                fullOutput += `<div class="explanation-section">`;
                fullOutput += `<h4>Explanation of Stored Forms</h4>`;
                if (storeActions.length > 0) {
                    const totalStored = storeActions.reduce((sum, action) => sum + action.qty, 0);
                    fullOutput += `<p>* (${totalStored}) forms were stored because there were no remaining panel requirements in this cast that could be produced on them.</p>`;
                } else {
                    fullOutput += `<p>No forms were stored in this cast as all available forms were utilized for production.</p>`;
                }
                fullOutput += `</div>`;
                fullOutput += `<p><strong>Ending Form Inventory: ${formInventory.length} forms total.</strong></p>`;
                fullOutput += `</div>`;
            });
            // Setup nav for schedule view
            document.getElementById('back-to-review-button').style.display = 'inline-block';
            document.getElementById('back-to-build-details-button').style.display = 'inline-block';
            document.getElementById('start-over').style.display = 'inline-block';
            document.getElementById('print-schedule-button').style.display = 'inline-block';
            document.getElementById('print-schedule-button').disabled = false;
            document.getElementById('print-note').style.display = 'inline';
            document.getElementById('generate-stickers-button').style.display = 'inline-block';
            document.getElementById('generate-stickers-button').disabled = false;
            document.getElementById('generate-tracking-sheet-button').disabled = false;
            document.getElementById('view-layout-button').disabled = false;
             // Hide others
             document.getElementById('back-to-schedule-button').style.display = 'none';
            const trackingPrintButton = document.getElementById('print-tracking-sheet-button');
            if (trackingPrintButton) trackingPrintButton.remove();
            const stickerPrintButton = document.getElementById('print-stickers-button');
            if (stickerPrintButton) stickerPrintButton.remove();
            let inventorySummary = '';
            const preExistingForms = formInventory.filter(f => f.lastUsedFor === 'Pre-existing');
            if (preExistingForms.length > 0) {
                inventorySummary += `<h3>Initial Form Inventory</h3>`;
                let inventoryList = `<table class="schedule-table"><tr><th>Form ID</th><th>Dimensions</th></tr>`;
                preExistingForms.forEach(form => {
                    inventoryList += `<tr><td>${form.id}</td><td>${form.formLength}" L x ${form.initialWidth}" W</td></tr>`;
                });
                inventoryList += '</table><hr>';
                inventorySummary += inventoryList;
            }
            outputDiv.innerHTML = inventorySummary + fullOutput;
            appState.finalFormInventory = formInventory; // Store for the layout viewer

            // Populate the new layout viewer
            // populateCastSelector(castingSchedule.length); // No longer needed
            // Draw all casts
            if (castingSchedule.length > 0) {
                // This will be handled by the 'view-layout-button' click now
            }
        }


        // =================================================================================
        // MODULE: UI & OUTPUT GENERATION
        // Functions for updating the DOM, displaying results, and handling UI views.
        // =================================================================================

        /**
         * Renders the data parsed from the uploaded file into HTML tables within the review container.
         * This allows the user to verify that their data was read correctly before proceeding.
         */
        function displayReviewData() {
            const { panelLegend, castingSchedule } = appState;
            const legendDiv = document.getElementById('review-panel-legend');
            const scheduleDiv = document.getElementById('review-casting-schedule');
            let legendHtml = '<table><tr><th>Panel ID</th><th>Length</th><th>Width</th><th>Thickness</th><th>Casting Type</th><th>Finish</th><th>Color</th><th>Comments</th></tr>';
            for (const id in panelLegend) {
                const panel = panelLegend[id];
                legendHtml += `<tr>
                    <td>${id}</td>
                    <td>${panel.length}</td>
                    <td>${panel.width}</td>
                    <td>${panel.thickness}</td>
                    <td>${panel.castingType}</td>
                    <td>${panel.finish}</td>
                    <td>${panel.color}</td>
                    <td>${panel.comments}</td>
                </tr>`;
            }
            legendHtml += '</table>';
            legendDiv.innerHTML = legendHtml;
            let scheduleHtml = '<table><tr><th style="width:10%;">Cast #</th><th>Panels (Qty)</th></tr>';
            castingSchedule.forEach((cast, index) => {
                const panelList = Object.entries(cast)
                    .map(([panelId, qty]) => `${panelId}: ${qty}`)
                    .join(', ');
                scheduleHtml += `<tr><td>${index + 1}</td><td>${panelList}</td></tr>`;
            });
            scheduleHtml += '</table>';
            scheduleDiv.innerHTML = scheduleHtml;
            // Display project info
            const projectInfoDiv = document.getElementById('review-project-info');
            if (appState.projectInfo && Object.keys(appState.projectInfo).length > 0) {
                let projectInfoHtml = '<table style="width:100%; border-collapse: collapse;">';
                for (const key in appState.projectInfo) {
                    const value = (appState.projectInfo[key] || '').replace(/\n/g, '<br>');
                    projectInfoHtml += `<tr style="border-bottom: 1px solid var(--border-color);"><th style="padding: 8px; text-align: left; width: 30%;">${key}</th><td style="padding: 8px; text-align: left;">${value}</td></tr>`;
                }
                projectInfoHtml += '</table>';
                projectInfoDiv.innerHTML = projectInfoHtml;
            } else {
                projectInfoDiv.innerHTML = '<p>No project information found in the uploaded file.</p>';
            }
            document.getElementById('input-container').style.display = 'none';
            const reviewActions = document.getElementById('review-actions');
            reviewActions.style.top = `0px`;
            reviewActions.style.display = 'flex';
            document.getElementById('review-container').style.display = 'block';
            document.getElementById('output').style.display = 'none';
        }

        /**
         * Generates and displays printable stickers for each individual panel instance.
         * It calculates unique IDs for every panel, reads layout settings from the UI,
         * and dynamically creates the sticker HTML and CSS for printing.
         */
        function generateStickers() {
             const { panelLegend, castingSchedule, projectName } = appState;
             // Read layout settings from the form
             const settings = {
                 width: parseFloat(document.getElementById('sticker-width').value),
                 height: parseFloat(document.getElementById('sticker-height').value),
                 cols: parseInt(document.getElementById('sticker-cols').value, 10),
                 rows: parseInt(document.getElementById('sticker-rows').value, 10),
                 marginTop: parseFloat(document.getElementById('sheet-margin-top').value),
                 marginLeft: parseFloat(document.getElementById('sheet-margin-left').value),
                 gapV: parseFloat(document.getElementById('gap-vertical').value),
                 gapH: parseFloat(document.getElementById('gap-horizontal').value)
             };
             const stickersPerPage = settings.cols * settings.rows;
             // Generate unique panel IDs
             let panelInstanceCounter = {};
             const allPanelsWithUniqueIds = [];
             castingSchedule.forEach(cast => {
                 const sortedPanelIds = Object.keys(cast).sort();
                 for (const panelId of sortedPanelIds) {
                     for (let i = 0; i < cast[panelId]; i++) {
                         if (!panelInstanceCounter[panelId]) {
                             panelInstanceCounter[panelId] = 0;
                         }
                         panelInstanceCounter[panelId]++;
                         const uniqueId = `${panelId}.${String(panelInstanceCounter[panelId]).padStart(2, '0')}`;
                         allPanelsWithUniqueIds.push({ panelId, uniqueId });
                     }
                 }
             });
             // --- Dynamic CSS for sticker layout ---
             const existingStyle = document.getElementById('dynamic-sticker-style');
             if (existingStyle) existingStyle.remove();
             const style = document.createElement('style');
             style.id = 'dynamic-sticker-style';
             style.innerHTML = `
                @media print {
                    @page {
                        size: letter portrait;
                        margin: ${settings.marginTop}in ${settings.marginLeft}in;
                    }
                    .sticker-sheet {
                        box-shadow: none !important;
                        border: none !important;
                    }
                    .sticker {
                        border: 1px solid #000 !important;
                    }
                }
                 .sticker-sheet {
                     display: grid;
                     grid-template-columns: repeat(${settings.cols}, ${settings.width}in);
                     grid-template-rows: repeat(${settings.rows}, ${settings.height}in);
                     gap: ${settings.gapV}in ${settings.gapH}in;
                     width: calc(${settings.cols} * ${settings.width}in + (${settings.cols} - 1) * ${settings.gapH}in);
                     padding: 20px; /* Padding for on-screen view only */
                     margin: auto; /* Center on screen */
                     background-color: #fff;
                     box-shadow: var(--shadow-lg);
                     page-break-after: always;
                 }
                 .sticker-sheet:last-of-type {
                     page-break-after: avoid;
                 }
                 .sticker {
                     width: ${settings.width}in;
                     height: ${settings.height}in;
                     border: 1px solid #ccc; /* Visual guide for screen */
                     box-sizing: border-box;
                     padding: 4px;
                     font-size: 7pt;
                     color: #000;
                     overflow: hidden;
                     display: flex;
                     flex-direction: column;
                     justify-content: space-between;
                 }
             `;
             document.head.appendChild(style);
             const stickerContainer = document.getElementById('sticker-sheet-container');
             stickerContainer.innerHTML = ''; // Clear previous content
             const pageTitle = document.createElement('h2');
             pageTitle.textContent = 'Tracking Tickets';
             stickerContainer.appendChild(pageTitle);
             const pageDescription = document.createElement('p');
             pageDescription.textContent = 'These stickers provide essential panel information for tracking during production.';
             stickerContainer.appendChild(pageDescription);
             // Create and populate sticker sheets
             for (let i = 0; i < allPanelsWithUniqueIds.length; i += stickersPerPage) {
                 const sheetPanels = allPanelsWithUniqueIds.slice(i, i + stickersPerPage);
                 const stickerSheet = document.createElement('div');
                 stickerSheet.className = 'sticker-sheet';
                 sheetPanels.forEach(({ panelId, uniqueId }) => {
                     const panel = panelLegend[panelId];
                     if (!panel) return;
                     const sticker = document.createElement('div');
                     sticker.className = 'sticker';
                     sticker.innerHTML = `
                         <div class="sticker-header">
                             <span>${projectName}</span>
                             <span><strong>${uniqueId}</strong></span>
                         </div>
                         <div class="sticker-body">
                             <div class="sticker-dims">
                                 L: ${panel.length || 'N/A'} | W: ${panel.width || 'N/A'} | T: ${panel.thickness || 'N/A'}
                             </div>
                             <div class="qc-boxes">
                                 <div class="qc-box">M</div>
                                 <div class="qc-box">F</div>
                                 <div class="qc-box">C</div>
                                 <div class="qc-box">W</div>
                             </div>
                         </div>
                         <div class="sticker-footer">
                             <span>${panel.finish || ''}</span>
                             <span>${panel.color || ''}</span>
                         </div>
                     `;
                     stickerSheet.appendChild(sticker);
                 });
                 stickerContainer.appendChild(stickerSheet);
             }
             // Update UI
             document.getElementById('sticker-settings-container').style.display = 'none';
             stickerContainer.style.display = 'block';
             document.getElementById('output-controls').style.display = 'block'; // Keep controls visible
             // Left
             document.getElementById('back-to-schedule-button').style.display = 'inline-block';
             // Middle
             const middleNav = document.getElementById('nav-middle-controls');
             if (!document.getElementById('print-stickers-button')) {
                 const stickerPrintButton = document.createElement('button');
                 stickerPrintButton.id = 'print-stickers-button';
                 stickerPrintButton.textContent = 'Print Stickers';
                 stickerPrintButton.onclick = () => window.print();
                 middleNav.appendChild(stickerPrintButton);
             }
             // Hide others
             document.getElementById('start-over').style.display = 'none';
             document.getElementById('back-to-review-button').style.display = 'none';
             document.getElementById('back-to-build-details-button').style.display = 'none';
             document.getElementById('back-to-schedule-button').style.display = 'inline-block';
             document.getElementById('print-schedule-button').style.display = 'none';
             document.getElementById('print-note').style.display = 'none';
             document.getElementById('generate-stickers-button').style.display = 'none';
             document.getElementById('generate-tracking-sheet-button').style.display = 'none';
             const trackingPrintButton = document.getElementById('print-tracking-sheet-button');
             if (trackingPrintButton) trackingPrintButton.remove();
        }

        /**
         * Generates a printable tracking sheet organized by cast.
         * This sheet provides a checklist for quality control at various production stages for each unique panel.
         */
        function generateTrackingSheet() {
            const { panelLegend, castingSchedule, projectName } = appState;
            if (!panelLegend || !castingSchedule) {
                alert('Please generate a schedule first.');
                return;
            }
            const trackingContainer = document.getElementById('tracking-sheet-container');
            trackingContainer.innerHTML = ''; // Clear previous content
            let panelInstanceCounter = {};
            let fullHtml = `<h2>Tracking Sheets</h2>
            <p>These sheets provide a detailed record for quality control and tracking of each panel throughout the production process.</p>`;
            castingSchedule.forEach((cast, castIndex) => {
                const castNumber = castIndex + 1;
                fullHtml += `<div class="tracking-sheet-print-container">`;
                fullHtml += `<h3>Cast ${castNumber}</h3>`;
                fullHtml += `<table class="schedule-table">
                    <thead>
                        <tr>
                            <th>Panel Unique ID</th>
                            <th>Mill QC</th>
                            <th>Formout QC</th>
                            <th>Casting QC</th>
                            <th>Wash QC</th>
                            <th>Seal QC</th>
                            <th>Crate QC</th>
                            <th>Pack QC</th>
                        </tr>
                    </thead>
                    <tbody>`;
                const sortedPanelIds = Object.keys(cast).sort();
                for (const panelId of sortedPanelIds) {
                    for (let i = 0; i < cast[panelId]; i++) {
                        if (!panelInstanceCounter[panelId]) {
                            panelInstanceCounter[panelId] = 0;
                        }
                        panelInstanceCounter[panelId]++;
                        const uniqueId = `${panelId}.${String(panelInstanceCounter[panelId]).padStart(2, '0')}`;
                        fullHtml += `<tr>
                            <td><strong>${uniqueId}</strong></td>
                            <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
                        </tr>`;
                    }
                }
                fullHtml += `</tbody></table></div>`;
            });
            trackingContainer.innerHTML = fullHtml;
            // Update UI
            document.getElementById('output').style.display = 'none';
            document.getElementById('sticker-sheet-container').style.display = 'none';
            document.getElementById('sticker-settings-container').style.display = 'none';
            trackingContainer.style.display = 'block';
            document.getElementById('output-controls').style.display = 'block';
            // Update nav buttons
            document.getElementById('back-to-schedule-button').style.display = 'inline-block';
            document.getElementById('start-over').style.display = 'none';
            document.getElementById('back-to-review-button').style.display = 'none';
            document.getElementById('back-to-build-details-button').style.display = 'none';
            document.getElementById('print-schedule-button').style.display = 'none';
            document.getElementById('generate-stickers-button').style.display = 'inline-block';
            document.getElementById('generate-tracking-sheet-button').style.display = 'none';
            document.getElementById('print-note').style.display = 'none';
            const middleNav = document.getElementById('nav-middle-controls');
            if (!document.getElementById('print-tracking-sheet-button')) {
                const printButton = document.createElement('button');
                printButton.id = 'print-tracking-sheet-button';
                printButton.textContent = 'Print Tracking Sheet';
                printButton.onclick = () => window.print();
                middleNav.appendChild(printButton);
            }
        }


        // =================================================================================
        // MODULE: CASTING LAYOUT VISUALIZATION (INTERACTIVE)
        // =================================================================================

        /**
         * Populates the cast selector dropdown.
         */
        // No longer needed as all casts are displayed at once.
        function populateCastSelector() {}

        /**
         * Initializes the layout for a given cast. If a layout doesn't exist, it creates a default one.
         */
        function initializeLayoutForCast(castIndex) {
            if (layoutState.layouts[castIndex]) {
                return; // Already initialized
            }

            const { castingSchedule, panelLegend } = appState;
            const castData = castingSchedule[castIndex];
            if (!castData) return;

            const forms = [];
            let panelInstanceCounter = {};
            const sortedPanelIds = Object.keys(castData).sort();
            sortedPanelIds.forEach(panelId => {
                if (!panelInstanceCounter[panelId]) panelInstanceCounter[panelId] = 0;
                for (let i = 0; i < castData[panelId]; i++) {
                    panelInstanceCounter[panelId]++;
                    const uniqueId = `${panelId}.${String(panelInstanceCounter[panelId]).padStart(2, '0')}`;
                    forms.push({
                        id: uniqueId,
                        panelId: panelId,
                        x: 0, // Initial position in inches
                        y: 0,
                        rotation: 0, // In degrees
                        width: parseDim(panelLegend[panelId].width),
                        length: parseDim(panelLegend[panelId].length)
                    });
                }
            });

            // Auto-pack forms for the initial layout
            const packedForms = autoPackForms(forms, layoutState.panelDimensions.length, layoutState.panelDimensions.width);

            layoutState.layouts[castIndex] = {
                forms: packedForms,
                panelDimensions: { ...layoutState.panelDimensions }
            };
        }
        
        /**
         * A simple packing algorithm to provide a default layout.
         */
        function autoPackForms(forms, panelLength, panelWidth) {
            const areaKey = layoutState.selectedCastingArea;
            let formsToPack = [...forms];
            const packedForms = [];

            if (areaKey === 'presetA') {
                const area = castingAreas.presetA;
                let tableOffsetY = 0;
                const gap = 40;
                area.tables.forEach(table => {
                    let currentX = 5;
                    let currentY = tableOffsetY + 5;
                    let maxYinRow = 0;
                    const remainingFormsForNextTable = [];

                    formsToPack.forEach(form => {
                        if (currentX + form.length > table.length) {
                            currentX = 5;
                            currentY += maxYinRow + 5;
                            maxYinRow = 0;
                        }
                        if (currentY + form.width <= tableOffsetY + table.width) {
                            packedForms.push({ ...form, x: currentX, y: currentY });
                            currentX += form.length + 5;
                            if (form.width > maxYinRow) maxYinRow = form.width;
                        } else {
                            remainingFormsForNextTable.push(form);
                        }
                    });
                    formsToPack = remainingFormsForNextTable;
                    tableOffsetY += table.width + gap;
                });
                return packedForms;
            } else if (areaKey === 'presetB') {
                 const area = castingAreas.presetB;
                 const cols = 4;
                 const gap = 10;
                 const tableTemplate = area.tables[0]; // Now rotated: 120x60
                 const tablesToPackOn = Array.from({ length: 8 }, (_, i) => {
                     const col = i % cols;
                     const row = Math.floor(i / cols);
                     return {
                         ...tableTemplate,
                         offsetX: col * (tableTemplate.length + gap),
                         offsetY: row * (tableTemplate.width + gap)
                     };
                 });

                 tablesToPackOn.forEach(table => {
                     let currentX = table.offsetX + 5;
                     let currentY = table.offsetY + 5;
                     let maxYinRow = 0;
                     const remainingFormsForNextTable = [];

                     formsToPack.forEach(form => {
                         // Attempt to fit rotated form first if it's better
                         const canFitOriginal = currentX + form.length <= table.offsetX + table.length && currentY + form.width <= table.offsetY + table.width;
                         const canFitRotated = currentX + form.width <= table.offsetX + table.length && currentY + form.length <= table.offsetY + table.width;

                         if (canFitRotated && (!canFitOriginal || form.width < form.length)) {
                             // Rotate the form if it fits better or is the only way it fits
                             form.rotation = 90;
                             [form.length, form.width] = [form.width, form.length]; // Swap dimensions for packing
                         }

                         if (currentX + form.length > table.offsetX + table.length) {
                             currentX = table.offsetX + 5;
                             currentY += maxYinRow + 5;
                             maxYinRow = 0;
                         }

                         if (currentY + form.width <= table.offsetY + table.width) {
                             packedForms.push({ ...form, x: currentX, y: currentY });
                             currentX += form.length + 5;
                             if (form.width > maxYinRow) maxYinRow = form.width;
                         } else {
                             remainingFormsForNextTable.push(form);
                         }
                         // Revert dimensions if swapped for packing
                         if (form.rotation === 90) {
                            [form.length, form.width] = [form.width, form.length];
                         }
                     });
                     formsToPack = remainingFormsForNextTable;
                 });
                 return packedForms;
            } else { // custom
                // Original packing logic for custom area
                let currentX = 5;
                let currentY = 5;
                let maxYinRow = 0;
                return forms.map(form => {
                    if (currentX + form.length > panelLength) {
                        currentX = 5;
                        currentY += maxYinRow + 5;
                        maxYinRow = 0;
                    }
                    const packedForm = { ...form, x: currentX, y: currentY };
                    currentX += form.length + 5;
                    if (form.width > maxYinRow) maxYinRow = form.width;
                    return packedForm;
                });
            }
        }


        /**
         * Main drawing function for the interactive canvas.
         */
        function drawCastingLayout(castIndex, canvas) {
            const { panelLegend } = appState;
            const ctx = canvas.getContext('2d');
            const wrapper = canvas.parentElement; // The canvas-wrapper div
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;

            const currentLayout = layoutState.layouts[castIndex];
            if (!currentLayout) {
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = '16px sans-serif';
                ctx.fillText('No layout data for this cast.', canvas.width / 2, canvas.height / 2);
                return;
            }

            const { forms, panelDimensions } = currentLayout;
            const { length: panelLength, width: panelWidth } = panelDimensions;

            const padding = 50;
            const scaleX = (canvas.width - padding * 2) / panelLength;
            const scaleY = (canvas.height - padding * 2) / panelWidth;
            const scale = Math.min(scaleX, scaleY);

            const panelPixelWidth = panelLength * scale;
            const panelPixelHeight = panelWidth * scale;
            const panelX = (canvas.width - panelPixelWidth) / 2;
            const panelY = (canvas.height - panelPixelHeight) / 2;

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-main').trim();
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            ctx.lineWidth = 2;

            const areaKey = layoutState.selectedCastingArea;
            const drawLabels = () => {
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                if (areaKey === 'presetA') {
                    const area = castingAreas.presetA;
                    let tableOffsetY = 0;
                    const gap = 40;
                    area.tables.forEach((table, index) => {
                        const tableY = panelY + tableOffsetY * scale;
                        const label = `Table ${index + 1}: ${table.length / 12}' x ${table.width / 12}'`;
                        const textMetrics = ctx.measureText(label);
                        ctx.fillStyle = 'rgba(44, 62, 80, 0.75)'; // Semi-transparent background
                        ctx.fillRect(panelX, tableY, textMetrics.width + 10, 20);
                        ctx.fillStyle = '#ecf0f1';
                        ctx.fillText(label, panelX + 5, tableY + 3);
                        tableOffsetY += table.width + gap;
                    });
                } else if (areaKey === 'presetB') {
                    const area = castingAreas.presetB;
                    const table = area.tables[0];
                    const cols = 4;
                    const rows = 2;
                    const gap = 10;
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const tableIndex = row * cols + col;
                            const tableOffsetX = col * (table.length + gap);
                            const tableOffsetY = row * (table.width + gap);
                            const tableX = panelX + tableOffsetX * scale;
                            const tableY = panelY + tableOffsetY * scale;
                            const label = `Table ${tableIndex + 1}: ${table.length / 12}' x ${table.width / 12}'`;
                            const textMetrics = ctx.measureText(label);
                            ctx.fillStyle = 'rgba(44, 62, 80, 0.75)';
                            ctx.fillRect(tableX, tableY, textMetrics.width + 10, 20);
                            ctx.fillStyle = '#ecf0f1';
                            ctx.fillText(label, tableX + 5, tableY + 3);
                        }
                    }
                } else {
                    ctx.fillStyle = 'rgba(44, 62, 80, 0.75)';
                    const label = `Casting Area: ${panelLength}" x ${panelWidth}"`;
                    const textMetrics = ctx.measureText(label);
                    ctx.fillRect(panelX, panelY - 20, textMetrics.width + 10, 20);
                    ctx.fillStyle = '#ecf0f1';
                    ctx.fillText(label, panelX + 5, panelY - 17);
                }
            };

            if (areaKey === 'presetA') {
                const area = castingAreas.presetA;
                let tableOffsetY = 0;
                const gap = 40;
                area.tables.forEach(table => {
                    ctx.strokeRect(panelX, panelY + tableOffsetY * scale, table.length * scale, table.width * scale);
                    tableOffsetY += table.width + gap;
                });
            } else if (areaKey === 'presetB') {
                const area = castingAreas.presetB;
                const table = area.tables[0];
                const cols = 4;
                const rows = 2;
                const gap = 10;
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const tableOffsetX = col * (table.length + gap);
                        const tableOffsetY = row * (table.width + gap);
                        ctx.strokeRect(panelX + tableOffsetX * scale, panelY + tableOffsetY * scale, table.length * scale, table.width * scale);
                    }
                }
            } else {
                ctx.strokeRect(panelX, panelY, panelPixelWidth, panelPixelHeight);
            }

            forms.forEach(form => {
                const formPixelLength = form.length * scale;
                const formPixelWidth = form.width * scale;
                const formPixelX = panelX + form.x * scale;
                const formPixelY = panelY + form.y * scale;

                ctx.save();
                // Move the canvas origin to the center of where the form should be
                ctx.translate(formPixelX + formPixelLength / 2, formPixelY + formPixelWidth / 2);
                // Rotate the canvas around the new origin
                ctx.rotate(form.rotation * Math.PI / 180);

                // Set fill style based on selection
                ctx.fillStyle = form.id === layoutState.selectedFormId ? 'rgba(231, 76, 60, 0.8)' : 'rgba(52, 152, 219, 0.8)';
                
                // Draw the rectangle centered on the new origin
                ctx.fillRect(-formPixelLength / 2, -formPixelWidth / 2, formPixelLength, formPixelWidth);
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(-formPixelLength / 2, -formPixelWidth / 2, formPixelLength, formPixelWidth);

                // Draw the text centered on the new origin
                ctx.fillStyle = '#ecf0f1';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const fontSize = Math.max(8, Math.min(14, formPixelWidth / 2.5, formPixelLength / (form.panelId.length * 0.8)));
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.fillText(form.panelId, 0, 0);

                // Restore the canvas state to before the translation and rotation
                ctx.restore();
            });
            
            // Draw labels on top of forms
            drawLabels();
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function isPointInRotatedRect(point, form, panelOrigin, scale) {
            const formPixelLength = form.length * scale;
            const formPixelWidth = form.width * scale;
            const formPixelX = panelOrigin.x + form.x * scale;
            const formPixelY = panelOrigin.y + form.y * scale;

            const centerX = formPixelX + formPixelLength / 2;
            const centerY = formPixelY + formPixelWidth / 2;

            // Translate point to be relative to the rectangle's center
            const translatedX = point.x - centerX;
            const translatedY = point.y - centerY;

            // Rotate the point back
            const angleRad = -form.rotation * Math.PI / 180;
            const rotatedX = translatedX * Math.cos(angleRad) - translatedY * Math.sin(angleRad);
            const rotatedY = translatedX * Math.sin(angleRad) + translatedY * Math.cos(angleRad);

            // Check if the rotated point is inside the non-rotated rectangle
            return Math.abs(rotatedX) <= formPixelLength / 2 && Math.abs(rotatedY) <= formPixelWidth / 2;
        }

        function handleCanvasMouseDown(e) {
            const canvas = e.target;
            const castIndex = parseInt(canvas.dataset.castIndex, 10);
            if (isNaN(castIndex)) return;

            layoutState.activeCastIndex = castIndex; // Set the active cast

            const mousePos = getMousePos(canvas, e);
            const currentLayout = layoutState.layouts[castIndex];
            if (!currentLayout) return;

            const { forms, panelDimensions } = currentLayout;
            const { length: panelLength, width: panelWidth } = panelDimensions;
            const padding = 50;
            const scale = Math.min((canvas.width - padding * 2) / panelLength, (canvas.height - padding * 2) / panelWidth);
            const panelX = (canvas.width - (panelLength * scale)) / 2;
            const panelY = (canvas.height - (panelWidth * scale)) / 2;

            // Find which form was clicked (check in reverse order to select top-most)
            let clickedForm = null;
            for (let i = forms.length - 1; i >= 0; i--) {
                if (isPointInRotatedRect(mousePos, forms[i], {x: panelX, y: panelY}, scale)) {
                    clickedForm = forms[i];
                    break;
                }
            }

            if (clickedForm) {
                layoutState.selectedFormId = clickedForm.id;
                layoutState.isDragging = true;
                layoutState.isRotating = layoutState.rKeyDown;
                layoutState.dragStart.x = mousePos.x / scale - clickedForm.x;
                layoutState.dragStart.y = mousePos.y / scale - clickedForm.y;
                canvas.style.cursor = 'grabbing';
            } else {
                layoutState.selectedFormId = null;
            }
            drawCastingLayout(castIndex, canvas);
        }

        function handleCanvasMouseMove(e) {
            const canvas = e.target;
            const castIndex = parseInt(canvas.dataset.castIndex, 10);
            if (isNaN(castIndex)) return;

            const infoBox = document.getElementById('form-info-box');
            if (layoutState.isDragging && layoutState.selectedFormId) {
                const mousePos = getMousePos(canvas, e);
                const activeCastIndex = layoutState.activeCastIndex;
                const currentLayout = layoutState.layouts[activeCastIndex];
                if (!currentLayout) return;

                const form = currentLayout.forms.find(f => f.id === layoutState.selectedFormId);
                if (!form) return;

                const activeCanvas = document.querySelector(`.casting-canvas[data-cast-index="${activeCastIndex}"]`);
                if (!activeCanvas) return;

                const scale = Math.min(
                    (activeCanvas.width - 100) / currentLayout.panelDimensions.length,
                    (activeCanvas.height - 100) / currentLayout.panelDimensions.width
                );

                if (layoutState.isRotating) {
                    const centerX = form.x + form.length / 2;
                    const centerY = form.y + form.width / 2;
                    const mouseAngle = Math.atan2((mousePos.y / scale) - centerY, (mousePos.x / scale) - centerX);
                    form.rotation = mouseAngle * 180 / Math.PI;
                } else {
                    form.x = mousePos.x / scale - layoutState.dragStart.x;
                    form.y = mousePos.y / scale - layoutState.dragStart.y;
                }
                drawCastingLayout(activeCastIndex, activeCanvas);
            }

            // Info box logic - works on any hovered canvas
            const mousePos = getMousePos(canvas, e);
            const currentLayout = layoutState.layouts[castIndex];
            if (!currentLayout) {
                infoBox.style.display = 'none';
                return;
            }
            const { forms, panelDimensions } = currentLayout;
            const scale = Math.min((canvas.width - 100) / panelDimensions.length, (canvas.height - 100) / panelDimensions.width);
            const panelX = (canvas.width - (panelDimensions.length * scale)) / 2;
            const panelY = (canvas.height - (panelDimensions.width * scale)) / 2;

            let hoveredForm = null;
            for (let i = forms.length - 1; i >= 0; i--) {
                if (isPointInRotatedRect(mousePos, forms[i], {x: panelX, y: panelY}, scale)) {
                    hoveredForm = forms[i];
                    break;
                }
            }

            if (hoveredForm) {
                infoBox.style.display = 'block';
                infoBox.style.left = `${e.clientX + 15}px`;
                infoBox.style.top = `${e.clientY + 15}px`;
                infoBox.innerHTML = `
                    <strong>ID:</strong> ${hoveredForm.panelId}<br>
                    <strong>Dims:</strong> ${hoveredForm.length}" x ${hoveredForm.width}"<br>
                    <strong>Pos:</strong> (${hoveredForm.x.toFixed(1)}, ${hoveredForm.y.toFixed(1)})<br>
                    <strong>Rot:</strong> ${hoveredForm.rotation.toFixed(1)}
                `;
            } else {
                infoBox.style.display = 'none';
            }
        }

        function handleCanvasMouseUp(e) {
            layoutState.isDragging = false;
            layoutState.isRotating = false;
            document.querySelectorAll('.casting-canvas').forEach(c => c.style.cursor = 'grab');
        }

        function handleKeyDown(e) {
            if (e.key.toLowerCase() === 'r') {
                layoutState.rKeyDown = true;
                if (layoutState.isDragging) {
                    layoutState.isRotating = true;
                }
            }
        }

        function handleKeyUp(e) {
            if (e.key.toLowerCase() === 'r') {
                layoutState.rKeyDown = false;
                layoutState.isRotating = false;
            }
        }

        function saveLayout() {
            const castIndex = layoutState.activeCastIndex;
            if (layoutState.layouts[castIndex]) {
                try {
                    const layoutToSave = JSON.stringify(layoutState.layouts[castIndex]);
                    localStorage.setItem(`castingLayout_${castIndex}`, layoutToSave);
                    alert(`Layout for Cast ${castIndex + 1} saved!`);
                } catch (error) {
                    alert('Error saving layout.');
                    console.error(error);
                }
            }
        }

        function loadLayout() {
            const castIndex = layoutState.activeCastIndex;
            try {
                const savedLayout = localStorage.getItem(`castingLayout_${castIndex}`);
                if (savedLayout) {
                    layoutState.layouts[castIndex] = JSON.parse(savedLayout);
                    // Update UI with loaded dimensions
                    const { length, width } = layoutState.layouts[castIndex].panelDimensions;
                    document.getElementById('panel-length-input').value = length;
                    document.getElementById('panel-width-input').value = width;
                    const canvas = document.querySelector(`.casting-canvas[data-cast-index="${castIndex}"]`);
                    if (canvas) drawCastingLayout(castIndex, canvas);
                    alert(`Layout for Cast ${castIndex + 1} loaded!`);
                } else {
                    alert(`No saved layout found for Cast ${castIndex + 1}.`);
                }
            } catch (error) {
                alert('Error loading layout.');
                console.error(error);
            }
        }

        function resetLayout() {
            const castIndex = layoutState.activeCastIndex;
            // Clear the saved state for this cast
            delete layoutState.layouts[castIndex];
            // Re-initialize it with default packing
            initializeLayoutForCast(castIndex);
            const canvas = document.querySelector(`.casting-canvas[data-cast-index="${castIndex}"]`);
            if (canvas) drawCastingLayout(castIndex, canvas);
        }

        function generatePrintableLayout() {
            const container = document.getElementById('printable-layout-container');
            container.innerHTML = ''; // Clear previous content
            let fullSvgContent = '';

            appState.castingSchedule.forEach((cast, castIndex) => {
                const currentLayout = layoutState.layouts[castIndex];
                if (!currentLayout) return;

                const { forms, panelDimensions } = currentLayout;
                const { length: panelLength, width: panelWidth } = panelDimensions;

                let svgContent = `<div class="printable-cast-layout">`;
                const titleFontSize = Math.max(48, panelWidth / 4) * 0.8; // Reduced font size by 20%
                const viewBoxY = -titleFontSize * 1.2; // Dynamic Y for viewBox to accommodate large font
                const viewBoxHeight = panelWidth + 40 - viewBoxY; // Adjust height accordingly

                svgContent += `<svg class="printable-svg" viewBox="-10 ${viewBoxY} ${panelLength + 20} ${viewBoxHeight}" xmlns="http://www.w3.org/2000/svg">`;
                svgContent += `<rect x="-10" y="${viewBoxY}" width="${panelLength + 20}" height="${viewBoxHeight}" fill="white" />`;

                svgContent += `<text x="0" y="${-titleFontSize * 0.5}" font-family="sans-serif" font-size="${titleFontSize}" font-weight="bold" text-anchor="start" fill="black">${appState.projectName} - Cast ${castIndex + 1}</text>`;

                // Draw tables first
                const areaKey = layoutState.selectedCastingArea;
                if (areaKey === 'presetA') {
                    const area = castingAreas.presetA;
                    let tableOffsetY = 0;
                    const gap = 40;
                    area.tables.forEach(table => {
                        svgContent += `<rect x="0" y="${tableOffsetY}" width="${table.length}" height="${table.width}" fill="none" stroke="black" stroke-width="0.25" />`;
                        tableOffsetY += table.width + gap;
                    });
                } else if (areaKey === 'presetB') {
                    const area = castingAreas.presetB;
                    const table = area.tables[0];
                    const cols = 4;
                    const rows = 2;
                    const gap = 10;
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const tableOffsetX = col * (table.length + gap);
                            const tableOffsetY = row * (table.width + gap);
                            svgContent += `<rect x="${tableOffsetX}" y="${tableOffsetY}" width="${table.length}" height="${table.width}" fill="none" stroke="black" stroke-width="0.25" />`;
                        }
                    }
                } else {
                    svgContent += `<rect x="0" y="0" width="${panelLength}" height="${panelWidth}" fill="none" stroke="black" stroke-width="0.25" />`;
                }

                forms.forEach(form => {
                    const { x, y, length, width, rotation, panelId } = form;
                    svgContent += `<g transform="translate(${x}, ${y}) rotate(${rotation}, ${length / 2}, ${width / 2})">`;
                    svgContent += `<rect x="0" y="0" width="${length}" height="${width}" fill="#f0f0f0" stroke="black" stroke-width="0.1" />`;
                    const fontSize = Math.min(width * 0.4, length / (panelId.length * 0.6), 5);
                    svgContent += `<text x="${length / 2}" y="${width / 2}" font-family="sans-serif" font-size="${fontSize}" text-anchor="middle" dominant-baseline="middle" fill="black">${panelId}</text>`;
                    svgContent += `</g>`;
                });

                svgContent += `</svg></div>`;
                fullSvgContent += svgContent;
            });

            container.innerHTML = fullSvgContent;
            window.print();
        }


        function handleCastingAreaChange(event) {
            const selectedValue = event.target.value;
            layoutState.selectedCastingArea = selectedValue;
            const lengthInput = document.getElementById('panel-length-input');
            const widthInput = document.getElementById('panel-width-input');
            const updateButton = document.getElementById('update-panel-btn');

            if (selectedValue === 'presetA' || selectedValue === 'presetB') {
                const area = castingAreas[selectedValue];
                lengthInput.value = area.totalLength;
                widthInput.value = area.totalWidth;
                lengthInput.readOnly = true;
                widthInput.readOnly = true;
                updateButton.disabled = true;
                // This needs to trigger a full redraw sequence for all visible layouts
                layoutState.panelDimensions = { length: area.totalLength, width: area.totalWidth };
                
                document.querySelectorAll('.casting-canvas').forEach(canvas => {
                    const castIndex = parseInt(canvas.dataset.castIndex, 10);
                    if (layoutState.layouts[castIndex]) {
                        // Update each layout's dimensions and re-pack its forms
                        layoutState.layouts[castIndex].panelDimensions = { ...layoutState.panelDimensions };
                        const packedForms = autoPackForms(layoutState.layouts[castIndex].forms, area.totalLength, area.totalWidth);
                        layoutState.layouts[castIndex].forms = packedForms;
                        // Redraw this specific canvas
                        drawCastingLayout(castIndex, canvas);
                    }
                });

            }
        }


        // =================================================================================
        // MODULE: EVENT LISTENERS & UI HANDLERS
        // =================================================================================

        /**
         * Handles the file selection event. It uses the FileReader API to read the
         * selected Excel file, then passes the data to the `xlsx` library for parsing,
         * and finally calls `processData` to handle the parsed information.
         */
        function handleFileSelect() {
            const fileInput = document.getElementById('file-input');
            if (fileInput.files.length === 0) {
                alert('Please select a file to upload.');
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = event.target.result;
                    let parsedData;
                    const workbook = XLSX.read(data, { type: 'binary' });
                    parsedData = parseExcelData(workbook);
                    processData(parsedData);
                } catch (error) {
                    alert('Error processing file: ' + error.message);
                    console.error(error);
                }
            };
            reader.onerror = function(error) {
                alert('Failed to read file.');
                console.error('FileReader error:', error);
            };
            reader.readAsBinaryString(file);
        }

        /**
         * Enables or disables the main "Generate Schedule" button based on whether a
         * file has been selected by the user.
         */
        function updateGenerateButtonState() {
            const fileInput = document.getElementById('file-input');
            const generateButton = document.getElementById('generate-schedule');
            generateButton.disabled = fileInput.files.length === 0;
        }

        /**
         * Adds a new row to the "Pre-existing Forms" input section in the UI,
         * allowing the user to define multiple types of existing forms.
         */
        function addPreExistingFormRow() {
            formRowCount++;
            // Determine which container is currently visible to the user.
            const container = document.getElementById('pre-existing-forms-container-config');

            const newRow = document.createElement('div');
            newRow.className = 'form-row';
            newRow.innerHTML = `
                <span>Form ${formRowCount}</span>
                <input type="number" placeholder="Width" class="pre-existing-width">
                <input type="number" placeholder="Length" class="pre-existing-length">
                <input type="number" placeholder="Quantity" class="pre-existing-qty" value="1">
            `;
            container.appendChild(newRow);
        }

        /**
         * Resets the entire application UI to its initial state. This is used by the
         * "Start Over" button to clear all data and return to the file upload screen.
         */
        function resetToInitialView() {
            document.getElementById('output').style.display = 'none';
            document.getElementById('output-controls').style.display = 'none';
            document.getElementById('input-container').style.display = 'block';
            document.getElementById('file-input').value = '';
            appState.panelLegend = null;
            appState.castingSchedule = null;
            document.getElementById('output').innerHTML = '<p>Please upload an Excel file and click "Generate Schedule".</p>';
        }

        // --- Event Listener Setup ---
        // This function runs once the entire HTML document has been loaded and parsed.
        // It's the main entry point for attaching all the interactive event handlers.
        document.addEventListener('DOMContentLoaded', () => {
            // Main Actions & Auth
            authorizeButton.addEventListener('click', handleAuthClick);
            signoutButton.addEventListener('click', handleSignoutClick);
            document.getElementById('get-sheets-button').addEventListener('click', listSheetsInFolder);
            document.getElementById('load-selected-sheet').addEventListener('click', loadSelectedSheet);
            document.getElementById('generate-schedule').addEventListener('click', handleFileSelect);
            document.getElementById('confirm-generate').addEventListener('click', () => {
                document.getElementById('review-actions').style.display = 'none';
                document.getElementById('review-container').style.display = 'none';
                document.getElementById('casting-config-container').style.display = 'block';
            });

            // Config View Actions
           document.getElementById('back-to-review-from-config').addEventListener('click', () => {

               document.getElementById('casting-config-container').style.display = 'none';
               displayReviewData(); // Go back to review screen
           });

            document.getElementById('confirm-config-generate').addEventListener('click', () => {
                document.getElementById('casting-config-container').style.display = 'none';
                document.getElementById('output').style.display = 'block';
                document.getElementById('output-controls').style.display = 'block';
                generateSchedule(appState.panelLegend, appState.castingSchedule);
            });

            // Navigation & View Changes
            document.getElementById('back-to-build-details-button').addEventListener('click', () => {
                document.getElementById('output').style.display = 'none';
                document.getElementById('output-controls').style.display = 'none';
                document.getElementById('casting-config-container').style.display = 'block';
            });

            document.getElementById('back-to-review-button').addEventListener('click', () => {
                document.getElementById('output').style.display = 'none';
                document.getElementById('output-controls').style.display = 'none';
                document.getElementById('sticker-sheet-container').style.display = 'none';
                document.getElementById('tracking-sheet-container').style.display = 'none';
                document.getElementById('casting-layout-container').style.display = 'none';
                const trackingPrintButton = document.getElementById('print-tracking-sheet-button');
                if (trackingPrintButton) trackingPrintButton.remove();
                const stickerPrintButton = document.getElementById('print-stickers-button');
                if (stickerPrintButton) stickerPrintButton.remove();
                displayReviewData();
            });
            document.getElementById('cancel-review').addEventListener('click', () => {
                document.getElementById('review-actions').style.display = 'none';
                document.getElementById('review-container').style.display = 'none';
                document.getElementById('output').style.display = 'none';
                document.getElementById('input-container').style.display = 'block';
                document.getElementById('file-input').value = '';
                const configContainer = document.getElementById('pre-existing-forms-container-config');
                configContainer.innerHTML = `
                    <div class="form-row">
                        <span>Form 1</span>
                        <input type="number" placeholder="Width" class="pre-existing-width">
                        <input type="number" placeholder="Length" class="pre-existing-length">
                        <input type="number" placeholder="Quantity" class="pre-existing-qty" value="1">
                    </div>
                `;
                formRowCount = 1;
            });
            document.getElementById('start-over').addEventListener('click', resetToInitialView);
            document.getElementById('back-to-schedule-button').addEventListener('click', () => {
               document.getElementById('sticker-sheet-container').style.display = 'none';
               document.getElementById('sticker-settings-container').style.display = 'none';
               document.getElementById('tracking-sheet-container').style.display = 'none';
               document.getElementById('casting-layout-container').style.display = 'none';
               document.getElementById('output').style.display = 'block';
               document.getElementById('output-controls').style.display = 'block';
               
               // Left
               document.getElementById('start-over').style.display = 'inline-block';
               document.getElementById('back-to-review-button').style.display = 'inline-block';
               document.getElementById('back-to-build-details-button').style.display = 'inline-block';
               document.getElementById('back-to-schedule-button').style.display = 'none';
     
               // Middle
               document.getElementById('print-schedule-button').style.display = 'inline-block';
               document.getElementById('print-note').style.display = 'inline';
     
               // Right
               document.getElementById('generate-stickers-button').style.display = 'inline-block';
               document.getElementById('generate-tracking-sheet-button').style.display = 'inline-block';
               document.getElementById('view-layout-button').style.display = 'inline-block';
      
               const stickerPrintButton = document.getElementById('print-stickers-button');
               if (stickerPrintButton) stickerPrintButton.remove();
               const trackingPrintButton = document.getElementById('print-tracking-sheet-button');
               if (trackingPrintButton) trackingPrintButton.remove();
     
               const stickerStyle = document.getElementById('dynamic-sticker-style');
               if(stickerStyle) stickerStyle.remove();
           });

            // Input Handlers
            document.getElementById('file-input').addEventListener('change', updateGenerateButtonState);
            document.getElementById('add-form-row-config').addEventListener('click', addPreExistingFormRow);

            document.getElementById('view-layout-button').addEventListener('click', () => {
                document.getElementById('output').style.display = 'none';
                document.getElementById('sticker-sheet-container').style.display = 'none';
                document.getElementById('sticker-settings-container').style.display = 'none';
                document.getElementById('tracking-sheet-container').style.display = 'none';
                
                const layoutContainer = document.getElementById('casting-layout-container');
                layoutContainer.style.display = 'block';
                
                const layoutsWrapper = document.getElementById('layouts-wrapper');
                layoutsWrapper.innerHTML = ''; // Clear previous layouts

                // Trigger change event to set initial state from dropdown
                handleCastingAreaChange({ target: document.getElementById('casting-area-selector') });

                appState.castingSchedule.forEach((cast, castIndex) => {
                    initializeLayoutForCast(castIndex);

                    // Create a container for each cast's title and canvas
                    const castView = document.createElement('div');
                    castView.className = 'cast-view';
                    castView.style.marginBottom = '40px';

                    const title = document.createElement('h3');
                    title.textContent = `Cast ${castIndex + 1}`;
                    title.style.borderBottom = '2px solid var(--accent-color)';
                    title.style.paddingBottom = '10px';
                    
                    const newCanvasWrapper = document.createElement('div');
                    newCanvasWrapper.className = 'canvas-wrapper';

                    const newCanvas = document.createElement('canvas');
                    newCanvas.className = 'casting-canvas';
                    newCanvas.dataset.castIndex = castIndex; // Store index for event handling
                    
                    newCanvasWrapper.appendChild(newCanvas);
                    castView.appendChild(title);
                    castView.appendChild(newCanvasWrapper);
                    layoutsWrapper.appendChild(castView);

                    drawCastingLayout(castIndex, newCanvas);

                    // Add event listeners to the new canvas
                    newCanvas.addEventListener('mousedown', handleCanvasMouseDown);
                    newCanvas.addEventListener('mousemove', handleCanvasMouseMove);
                    newCanvas.addEventListener('mouseup', handleCanvasMouseUp);
                    newCanvas.addEventListener('mouseleave', handleCanvasMouseUp);
                });

                // Update nav
                document.getElementById('back-to-schedule-button').style.display = 'inline-block';
                document.getElementById('generate-stickers-button').style.display = 'inline-block';
                document.getElementById('generate-tracking-sheet-button').style.display = 'inline-block';
                document.getElementById('view-layout-button').style.display = 'none';
            });

            document.getElementById('casting-area-selector').addEventListener('change', handleCastingAreaChange);

            // New listeners for interactive layout
            // Event listeners are now added dynamically to each canvas.
            // The old static listeners are no longer needed.
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            document.getElementById('save-layout-btn').addEventListener('click', saveLayout);
            document.getElementById('load-layout-btn').addEventListener('click', loadLayout);
            document.getElementById('reset-layout-btn').addEventListener('click', resetLayout);
            document.getElementById('print-layout-btn').addEventListener('click', generatePrintableLayout);

            // Output Generation
            document.getElementById('print-schedule-button').addEventListener('click', () => window.print());
            document.getElementById('generate-stickers-button').addEventListener('click', () => {
                if (!appState.panelLegend || !appState.castingSchedule) {
                    alert('Please generate a schedule first.');
                    return;
                }
                document.getElementById('output').style.display = 'none';
                document.getElementById('tracking-sheet-container').style.display = 'none';
                document.getElementById('sticker-sheet-container').style.display = 'none';
                document.getElementById('casting-layout-container').style.display = 'none';
                document.getElementById('output-controls').style.display = 'none';
                document.getElementById('sticker-settings-container').style.display = 'block';
            });
            document.getElementById('confirm-generate-stickers').addEventListener('click', generateStickers);
            document.getElementById('cancel-sticker-generation').addEventListener('click', () => {
                document.getElementById('sticker-settings-container').style.display = 'none';
                document.getElementById('output').style.display = 'block';
                document.getElementById('output-controls').style.display = 'block';
            });
            document.getElementById('generate-tracking-sheet-button').addEventListener('click', generateTrackingSheet);

            // Initial State
            updateGenerateButtonState();
        });
    </script>
    </div>
</body>
</html>