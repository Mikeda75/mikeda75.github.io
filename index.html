<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CWE Production Dashboard</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --bg-main: #1F2937; /* Dark Slate-800 */
            --bg-card: #374151; /* Dark Slate-700 */
            --text-primary: #F3F4F6; /* Light Slate-100 */
            --text-secondary: #9CA3AF; /* Medium Slate-400 */
            --border-color: #4B5563; /* Dark Slate-600 */
            --border-color-strong: #6B7280; /* Dark Slate-500 */
            --accent-primary: #3B82F6; /* A strong, modern blue */
            --accent-primary-hover: #2563EB;
            --accent-success: #10B981;
            --accent-success-hover: #059669;
            --accent-danger: #EF4444;
            --accent-danger-hover: #DC2626;
            --disabled-bg: #4B5563;
            --disabled-text: #9CA3AF;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.15);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.2), 0 2px 4px -2px rgb(0 0 0 / 0.2);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.25), 0 4px 6px -4px rgb(0 0 0 / 0.25);
            --font-family-sans: 'Inter', sans-serif;
        }

        /* Base & Typography */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars on the body itself */
        }

        body {
            font-family: var(--font-family-sans);
            line-height: 1.6;
            background-color: var(--bg-main);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .main-container {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0; /* Remove padding to fill the entire window */
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling within the container */
            display: flex;
            flex-direction: column;
        }

        h1, h2, h3, h4 {
            color: var(--text-primary);
            font-weight: 600;
            margin-top: 0;
        }
        h1 { font-size: 2.25rem; letter-spacing: -0.02em; }
        h2 { font-size: 1.875rem; letter-spacing: -0.01em; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.125rem; color: var(--text-secondary); }
        p { color: var(--text-secondary); margin-bottom: 1.25rem; }
        small { font-size: 0.875rem; color: var(--text-secondary); }
        hr { border: 0; border-top: 1px solid var(--border-color); margin: 2rem 0; }

        /* Card & Container Styles */
        .card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem; /* Larger radius for modern look */
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-md);
            transition: box-shadow 0.3s ease;
        }
        .card:hover {
            box-shadow: var(--shadow-lg);
        }

        #header-container {
            background-color: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
            margin-bottom: 2rem;
            position: relative;
            text-align: center;
        }

        #header-logo {
            max-width: 250px;
            margin-bottom: 1rem;
        }

        #output, #review-container, #casting-config-container, #sticker-settings-container, #casting-layout-container {
            display: none;
        }

        /* Buttons */
        button {
            font-family: var(--font-family-sans);
            font-weight: 600;
            font-size: 0.95rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        button:focus-visible {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }
        .btn-primary {
            background-color: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }
        .btn-primary:hover {
            background-color: var(--accent-primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        .btn-success {
            background-color: var(--accent-success);
            color: white;
        }
        .btn-success:hover {
            background-color: var(--accent-success-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        .btn-secondary {
            background-color: var(--bg-card);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        .btn-secondary:hover {
            background-color: var(--bg-main);
            border-color: var(--border-color-strong);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Forms & Inputs */
        .input-option { margin-bottom: 2rem; }
        .paste-area { margin-top: 1rem; }
        .paste-area label, label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        input[type="text"], input[type="number"], input[type="file"], textarea, select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            background-color: var(--bg-card);
            color: var(--text-primary);
            font-family: var(--font-family-sans);
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
        }
        input[type="file"] {
            padding: 0.5rem;
            background-color: var(--bg-main);
        }
        input:focus-visible, textarea:focus-visible, select:focus-visible {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }
        ::placeholder { color: var(--text-secondary); opacity: 0.7; }

        /* Tables */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: var(--bg-main);
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: var(--bg-card);
        }
        tr:nth-child(odd) {
            background-color: #4B5563; /* Slightly different for odd rows */
        }

        /* Specific Component Styles */
        #output-controls {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-md);
            display: none; /* Hidden by default */
        }
        #review-actions {
            display: none;
            position: sticky;
            top: 1rem;
            background-color: rgba(55, 65, 81, 0.8); /* --bg-card with alpha */
            backdrop-filter: blur(8px);
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            z-index: 99;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 2rem;
        }
        .template-link {
            text-decoration: none;
            padding: 0.6rem 1.2rem;
            background-color: var(--bg-main);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .template-link:hover {
            background-color: var(--bg-card);
            border-color: var(--border-color-strong);
            box-shadow: var(--shadow-sm);
        }

        /* Casting Layout Visualization */
        #casting-layout-container h2 { margin-bottom: 1rem; }
        #casting-layout-container p { margin-bottom: 1.5rem; }
        .canvas-wrapper {
            position: relative;
            width: 100%;
            padding-top: 50%; /* Aspect Ratio 2:1 */
            background-color: #111827; /* Darker for contrast */
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
        }
        .casting-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #layout-controls {
            margin-bottom: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #layout-controls .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        #form-info-box {
            position: absolute;
            display: none;
            background: rgba(26, 26, 26, 0.85);
            backdrop-filter: blur(4px);
            border: 1px solid var(--border-color-strong);
            padding: 0.75rem;
            border-radius: 0.5rem;
            color: #F0F2F5;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 110;
            box-shadow: var(--shadow-lg);
        }

        /* Sticker Styles */
        .sticker-sheet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .sticker-sheet-header h2 {
            margin-bottom: 0;
        }
        .sticker-sheet-container { display: none; } /* Padding is now on the card */
        .sticker-sheet {
            display: flex;
            flex-wrap: wrap;
            gap: 0;
            width: 8.5in;
            min-height: 11in;
            margin: auto;
            background-color: #fff;
            box-shadow: var(--shadow-lg);
        }
        .sticker {
            box-sizing: border-box;
            width: 2in;
            height: 1in;
            border: 1px solid #ccc;
            padding: 4px;
            font-size: 7pt;
            color: #000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .sticker-header { display: flex; justify-content: space-between; font-weight: bold; }
        .sticker-dims { font-size: 6.5pt; }
        .sticker-body { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; }
        .sticker-footer { display: flex; justify-content: space-between; font-size: 6.5pt; }
        .qc-boxes { display: flex; justify-content: space-around; margin-top: 3px; }
        .qc-box { border: 1px solid #000; width: 12px; height: 12px; font-size: 6pt; text-align: center; line-height: 10px; }

        /* Collapsible Menu Styles */
        details {
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
            background-color: var(--bg-card); /* Give details a card background */
        }
        details[open] {
            border-color: var(--border-color-strong);
        }
        summary {
            font-weight: 600;
            font-size: 0.95rem;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            list-style: none; /* Remove default marker */
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        details:not([open]) summary:hover {
            background-color: var(--bg-main);
        }
        summary::-webkit-details-marker {
            display: none; /* Hide marker on Chrome */
        }
        summary::after {
            content: '▶'; /* Collapsed state icon */
            font-size: 0.8em;
            transition: transform 0.2s ease-in-out;
            color: var(--text-secondary);
        }
        details[open] > summary {
            border-bottom: 1px solid var(--border-color);
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        details[open] > summary::after {
            transform: rotate(90deg); /* Expanded state icon */
        }
        details > div { /* The settings content */
            padding: 1.5rem;
            background-color: var(--bg-main);
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        /* Print Styles */
        @media print {
            @page { size: letter landscape; margin: 0.5in; } /* Default page orientation */
            body {
                padding: 0; margin: 0; font-size: 10pt;
                background-color: #fff !important; color: #000 !important;
            }
            * { color: #000 !important; background-color: #fff !important; box-shadow: none !important; }
            .main-container { padding: 0.5in; max-width: 100%; }
            #header-container, #review-actions, #output-controls, .explanation-section, #print-note, #casting-layout-container, .card {
                display: none !important;
            }
            #printable-layout-container, #output[style*="display: block"], #sticker-sheet-container[style*="display: block"], #tracking-sheet-container[style*="display: block"] {
                display: block !important; border: none; padding: 0; margin: 0;
            }
            h3, h4 { page-break-after: avoid; font-size: 12pt; }
            table.schedule-table { width: 100% !important; font-size: 8pt; border-collapse: collapse; }
            .schedule-table tr { page-break-inside: avoid; }
            .schedule-table th, .schedule-table td { padding: 2px 4px; border: 1px solid #000 !important; }
            .schedule-table th { background-color: #eee !important; }
            .cast-schedule-print-container, .tracking-sheet-print-container, .printable-cast-layout { page-break-after: always; }
            #output .cast-schedule-print-container:last-of-type, #tracking-sheet-container .tracking-sheet-print-container:last-of-type, .printable-cast-layout:last-of-type { page-break-after: avoid; }
            .sticker { page-break-inside: avoid; }
            @page schedule-page { size: letter landscape; margin: 0.25in; }
            #output { page: schedule-page; }
            /* @page sticker-page is now generated dynamically in the script. */
            .sticker-sheet-container { page: sticker-page; }
            @page tracking-sheet-page { size: letter landscape; margin: 0.25in; }
            #tracking-sheet-container { page: tracking-sheet-page; }
        }

        body.printing .printing-target {
            display: block !important;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            border: none;
            margin: 0;
            padding: 0;
        }

        body.printing .main-container > *:not(.printing-target) {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(31, 41, 55, 0.8); backdrop-filter: blur(5px); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 10000; color: var(--text-primary);">
        <svg aria-hidden="true" class="w-8 h-8 text-gray-200 animate-spin dark:text-gray-600 fill-blue-600" style="width: 5rem; height: 5rem;" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/>
            <path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0492C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="var(--accent-primary)"/>
        </svg>
        <h2 style="margin-top: 1rem; font-size: 1.5rem; letter-spacing: 0.05em;">Loading Project Data...</h2>
    </div>
    <div class="main-container">
    <div id="output-controls" class="card">
        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; flex-wrap: wrap; gap: 1rem;">
            <div id="nav-left-controls" style="display: flex; gap: 0.5rem; align-items: center;">
                <button id="back-to-schedule-button" class="btn-secondary" style="display: none;">Back to Schedule</button>
                <button id="back-to-review-button" class="btn-secondary">Back to Review</button>
            </div>
            <div id="nav-middle-controls" style="display: flex; gap: 0.5rem; align-items: center;">
                <button id="print-schedule-button" class="btn-primary" disabled>Print Schedule</button>
                <small id="print-note" style="display: none;">(For best results, use 'Fit to page' in print preview)</small>
            </div>
            <div id="nav-right-controls" style="display: flex; gap: 0.5rem; align-items: center;">
               <button id="generate-tracking-sheet-button" class="btn-secondary" disabled>Generate Tracking Sheet</button>
               <button id="generate-stickers-button" class="btn-secondary" disabled>Generate Stickers</button>
               <button id="view-layout-button" class="btn-secondary" disabled>View Casting Layout</button>
               <button id="fullscreen-btn" class="btn-secondary" title="Toggle Fullscreen"></button>
            </div>
        </div>
    </div>
    <div id="review-actions">
        <button id="confirm-generate" class="btn-success">Confirm and Generate Schedule</button>
    </div>
    <div id="review-container" class="card">
        <h2>Confirm Project Data</h2>
        <p>Review the parsed Project Information, Panel Legend, and Casting Schedule. If correct, click "Confirm and Generate Schedule" to proceed to optimization settings.</p>
        <div class="review-section">
            <h3>Project Information</h3>
            <div id="review-project-info"></div>
        </div>
        <div class="review-section">
            <h3>Panel Legend</h3>
            <div id="review-panel-legend"></div>
        </div>
        <div class="review-section">
            <h3>Casting Schedule</h3>
            <div id="review-casting-schedule"></div>
        </div>
    </div>
    <div id="output" class="card" style="display: none;">
        <h2>Casting Schedule</h2>
        <p>This schedule displays the casting plan directly from the "Casting Schedule" tab in the Google Sheet.</p>
    </div>
    <div id="sticker-sheet-container" class="card">
        <div class="sticker-sheet-header">
            <h2 style="margin-bottom: 0;">Tracking Tickets</h2>
        </div>
        <p>These stickers provide essential panel information for tracking during production.</p>

        <details id="sticker-settings-details">
            <summary>Configure Layout</summary>
            <div id="sticker-layout-settings">
                <h3 style="margin-top: 0;">Sticker Sheet Layout Settings</h3>
                <p>Adjust the layout to match your sticker paper. The default values are for a standard 30-label sheet (e.g., Avery 5160 / Sheet-Labels SL100).</p>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                    <div class="paste-area">
                        <label for="sticker-width">Sticker Width (inches)</label>
                        <input type="number" id="sticker-width" value="2.625" step="0.001">
                    </div>
                    <div class="paste-area">
                        <label for="sticker-height">Sticker Height (inches)</label>
                        <input type="number" id="sticker-height" value="1" step="0.001">
                    </div>
                    <div class="paste-area">
                        <label for="sticker-cols">Columns per Sheet</label>
                        <input type="number" id="sticker-cols" value="3" step="1">
                    </div>
                    <div class="paste-area">
                        <label for="sticker-rows">Rows per Sheet</label>
                        <input type="number" id="sticker-rows" value="10" step="1">
                    </div>
                    <div class="paste-area">
                        <label for="sheet-margin-top">Top/Bottom Margin (inches)</label>
                        <input type="number" id="sheet-margin-top" value="0.5" step="0.001">
                    </div>
                    <div class="paste-area">
                        <label for="sheet-margin-left">Left/Right Margin (inches)</label>
                        <input type="number" id="sheet-margin-left" value="0.1875" step="0.001">
                    </div>
                    <div class="paste-area">
                        <label for="gap-vertical">Vertical Gap (inches)</label>
                        <input type="number" id="gap-vertical" value="0" step="0.001">
                    </div>
                    <div class="paste-area">
                        <label for="gap-horizontal">Horizontal Gap (inches)</label>
                        <input type="number" id="gap-horizontal" value="0.15625" step="0.001">
                    </div>
                </div>
                <div style="margin-top: 20px; display: flex; gap: 0.5rem;">
                    <button id="confirm-generate-stickers" class="btn-success">Generate & View Stickers</button>
                    <button id="cancel-sticker-settings" class="btn-secondary">Cancel</button>
                </div>
            </div>
        </details>
        <div id="sticker-sheets-output" style="margin-top: 1.5rem;"></div>
    </div>
    <div id="tracking-sheet-container" class="card" style="display: none;"></div>
    <div id="casting-layout-container" class="card" style="display: none;">
        <h2>Casting Layout Visualization</h2>
        <p>Interactively place, move, and rotate forms for each cast. Save and load your layouts. <strong>Click and drag</strong> to move a form. <strong>Hold 'R' and drag</strong> to rotate.</p>
        <div id="layout-controls">
            <div class="control-row">
                <!-- Cast selector removed to show all layouts at once -->
                <div>
                    <label for="casting-area-selector">Casting Area:</label>
                    <select id="casting-area-selector">
                        <option value="presetA" selected>Preset A</option>
                        <option value="presetB">Preset B</option>
                    </select>
                </div>
                 <div>
                    <label for="form-offset-input">Form Base Offset (in):</label>
                    <input type="number" id="form-offset-input" value="0" step="0.125">
                </div>
                 <div>
                    <label for="panel-spacing-input">Panel Spacing (in):</label>
                    <input type="number" id="panel-spacing-input" value="5" step="1">
                </div>
                <div class="panel-dims" style="display: none;">
                    <label>Panel Dimensions (in):</label>
                    <input type="number" id="panel-length-input" placeholder="Length">
                    <input type="number" id="panel-width-input" placeholder="Width">
                    <button id="update-panel-btn" class="btn-secondary">Update Panel</button>
                </div>
            </div>
            <div class="control-row">
                <div style="display: flex; gap: 0.5rem;">
                    <button id="save-layout-btn" class="btn-secondary">Save Layout</button>
                    <button id="load-layout-btn" class="btn-secondary">Load Layout</button>
                    <button id="reset-layout-btn" class="btn-secondary">Reset Layout</button>
                    <button id="print-layout-btn" class="btn-primary">Print Layout</button>
                </div>
            </div>
        </div>
        <div id="layouts-wrapper">
            <!-- Casting layouts will be dynamically inserted here -->
        </div>
        <div id="form-info-box"></div>
    </div>

    <div id="printable-layout-container" style="display: none;"></div>

    <!-- ================================================================================= -->
    <!-- SCRIPT LOGIC -->
    <!-- All application logic is contained within this single script tag. -->
    <!-- ================================================================================= -->
    <script>
        // =================================================================================
        // MODULE: GOOGLE APPS SCRIPT INTEGRATION
        // =================================================================================

        /**
         * Fetches data from the active Google Sheet using google.script.run.
         * It calls the 'getSheetData' function in the backend Apps Script (Code.gs).
         */
        function loadDataFromActiveSheet() {
            const overlay = document.getElementById('loading-overlay');
            if(overlay) overlay.style.display = 'flex';

            // Call the Apps Script function. The 'withSuccessHandler' and 'withFailureHandler'
            // are callbacks that will execute when the server-side function returns.
            google.script.run
                .withSuccessHandler(data => {
                    if(overlay) overlay.style.display = 'none';
                    console.log("Data received from Apps Script:", data);
                    if (data.error) {
                        alert('Error from Apps Script: ' + data.error);
                        return;
                    }
                    // The data is already structured, so we can process it directly.
                    processData(data);
                })
                .withFailureHandler(error => {
                    if(overlay) overlay.style.display = 'none';
                    console.error('Google Apps Script execution error:', error);
                    alert('A critical error occurred while communicating with Google Sheets: ' + error.message);
                })
                .getSheetData();
        }


        // =================================================================================
        // MODULE: NAVIGATION
        // =================================================================================
        const Navigation = (() => {
            const views = [
                '#review-container', '#output',
                '#sticker-sheet-container', '#tracking-sheet-container', '#casting-layout-container'
            ];
            const controls = {
                main: '#output-controls',
                review: '#review-actions',
                backToSchedule: '#back-to-schedule-button',
                backToReview: '#back-to-review-button',
                printSchedule: '#print-schedule-button',
                printNote: '#print-note',
                generateStickers: '#generate-stickers-button',
                generateTracking: '#generate-tracking-sheet-button',
                viewLayout: '#view-layout-button',
                printStickers: '#print-stickers-button', // Will be created dynamically
                printTracking: '#print-tracking-sheet-button' // Will be created dynamically
            };

            function showView(viewId) {
                console.log(`Switching to view: ${viewId}`);
                views.forEach(v => {
                    const el = document.querySelector(v);
                    if (el) el.style.display = (v === viewId) ? 'block' : 'none';
                });
                updateControls(viewId);
            }

            function updateControls(viewId) {
                const mainControls = document.querySelector(controls.main);
                const reviewActions = document.querySelector(controls.review);
                
                // Default states
                mainControls.style.display = 'none';
                reviewActions.style.display = 'none';
                document.querySelector(controls.backToSchedule).style.display = 'none';
                document.querySelector(controls.backToReview).style.display = 'inline-block';
                document.querySelector(controls.printSchedule).style.display = 'none';
                document.querySelector(controls.printNote).style.display = 'none';
                document.querySelector(controls.generateStickers).style.display = 'inline-block';
                document.querySelector(controls.generateTracking).style.display = 'inline-block';
                document.querySelector(controls.viewLayout).style.display = 'inline-block';

                // Remove dynamically added print buttons
                const stickerPrintBtn = document.getElementById('print-stickers-button');
                if (stickerPrintBtn) stickerPrintBtn.remove();
                const trackingPrintBtn = document.getElementById('print-tracking-sheet-button');
                if (trackingPrintBtn) trackingPrintBtn.remove();


                switch (viewId) {
                    case '#review-container':
                        reviewActions.style.display = 'flex';
                        break;
                    case '#output':
                        mainControls.style.display = 'block';
                        document.querySelector(controls.printSchedule).style.display = 'inline-block';
                        document.querySelector(controls.printNote).style.display = 'inline';
                        break;
                    case '#sticker-sheet-container':
                    case '#tracking-sheet-container':
                    case '#casting-layout-container':
                        mainControls.style.display = 'block';
                        document.querySelector(controls.backToSchedule).style.display = 'inline-block';
                        document.querySelector(controls.backToReview).style.display = 'none';
                        document.querySelector(controls.generateStickers).style.display = (viewId === '#sticker-sheet-container') ? 'none' : 'inline-block';
                        document.querySelector(controls.generateTracking).style.display = (viewId === '#tracking-sheet-container') ? 'none' : 'inline-block';
                        document.querySelector(controls.viewLayout).style.display = (viewId === '#casting-layout-container') ? 'none' : 'inline-block';
                        
                        if (viewId === '#sticker-sheet-container') {
                             const middleNav = document.getElementById('nav-middle-controls');
                             const stickerPrintButton = document.createElement('button');
                             stickerPrintButton.id = 'print-stickers-button';
                             stickerPrintButton.className = 'btn-primary';
                             stickerPrintButton.textContent = 'Print Stickers';
                             stickerPrintButton.onclick = () => prepareAndPrint('sticker-sheet-container');
                             middleNav.appendChild(stickerPrintButton);
                        }
                        if (viewId === '#tracking-sheet-container') {
                            const middleNav = document.getElementById('nav-middle-controls');
                            const printButton = document.createElement('button');
                            printButton.id = 'print-tracking-sheet-button';
                            printButton.className = 'btn-primary';
                            printButton.textContent = 'Print Tracking Sheet';
                            printButton.onclick = () => prepareAndPrint('tracking-sheet-container');
                            middleNav.appendChild(printButton);
                        }
                        break;
                }
            }

            return {
                showView,
                updateControls
            };
        })();
        
          // =================================================================================
          // MODULE: APP STATE & INITIALIZATION
          // =================================================================================
        // Global variable to track the number of pre-existing form rows in the UI.
        let formRowCount = 1;

        // Centralized object to hold the application's state, including parsed data.
        const appState = {
            panelLegend: null,      // Object containing details for each panel type.
            panelLegendHeaders: [],   // Holds the original header order from the sheet.
            castingSchedule: null,  // Array of objects, where each object represents a day's cast.
            projectInfo: null,      // Object with project metadata (e.g., Project Name, Address).
            projectName: '',         // The name of the project, extracted for easy access.
            finalFormInventory: [],  // Holds the final state of the form inventory after scheduling.
            rawSheetData: {}        // Holds the raw text response for debugging.
        };
        
        // Holds the state for the interactive casting layout, including positions and rotations.
        const castingAreas = {
            presetA: {
                tables: [
                    { length: 65 * 12, width: 5 * 12 }, // 780x60
                    { length: 45 * 12, width: 5 * 12 }  // 540x60
                ],
                // Combined view for the canvas - updated for vertical stacking
                totalLength: Math.max(65 * 12, 45 * 12), // 780
                totalWidth: (5 * 12) + (5 * 12) + 40 // 120 + 40 for increased spacing
            },
            presetB: {
                tables: Array(8).fill({ length: 10 * 12, width: 5 * 12 }), // Rotated: 8 tables of 120x60
                // 2x4 grid layout
                totalLength: (4 * (10 * 12)) + (3 * 10), // 510 inches
                totalWidth: (2 * (5 * 12)) + (1 * 10)  // 130 inches
            }
        };

        const layoutState = {
            layouts: {}, // Keyed by castIndex
            activeCastIndex: 0,
            selectedFormId: null,
            dragStart: { x: 0, y: 0 },
            isDragging: false,
            isRotating: false,
            rKeyDown: false,
            panelDimensions: { length: 0, width: 0 },
            selectedCastingArea: 'presetA' // Default to Preset A
        };

        // =================================================================================
        // MODULE: DATA PARSING
        // =================================================================================


        /**
         * Parses a dimension string (e.g., "10' 5 1/2\"") into a single numerical value in inches.
         * Handles feet, inches, and fractional inches.
         * @param {string} dimStr The dimension string to parse.
         * @returns {number} The total dimension in inches. Returns 0 if the input is not a string.
         */
        function parseDim(dimStr) {
            if (typeof dimStr !== 'string' || !dimStr.trim()) return 0;

            let totalInches = 0;
            // Match feet (e.g., 10')
            const feetMatch = dimStr.match(/(\d+)\s*'/);
            if (feetMatch) {
                totalInches += parseInt(feetMatch[1], 10) * 12;
            }

            // Process the rest of the string for inches and fractions
            const inchesPart = dimStr.replace(/(\d+)\s*'/, '').trim();
            const inchParts = inchesPart.replace(/"/g, '').trim().split(/\s+/);

            for (const part of inchParts) {
                if (!part) continue;
                if (part.includes('/')) {
                    const fraction = part.split('/');
                    if (fraction.length === 2 && !isNaN(fraction[0]) && !isNaN(fraction[1]) && parseInt(fraction[1], 10) !== 0) {
                        totalInches += parseFloat(fraction[0]) / parseFloat(fraction[1]);
                    }
                } else if (!isNaN(part)) {
                    totalInches += parseFloat(part);
                }
            }
            return totalInches;
        }

        /**
         * Parses raw sheet data (an array of arrays) into a simple key-value object.
         * Assumes Column A contains the keys and Column B contains the values.
         * @param {Array<Array<string>>} data The raw 2D array from the sheet.
         * @returns {object} An object representing the key-value data.
         */
        function parseSheetAsKeyValue(data) {
            if (!data) return {};
            const obj = {};
            data.forEach(row => {
                if (row && row[0]) { // If there's a key in the first column
                    obj[row[0].toString().trim()] = row[1] ? row[1].toString().trim() : '';
                }
            });
            return obj;
        }

        /**
         * Parses raw sheet data into an array of objects, using the first row as headers.
         * @param {Array<Array<string>>} data The raw 2D array from the sheet.
         * @param {string} keyColumn The name of the column to use as the key for the main object.
         * @returns {object} An object where keys are from the keyColumn and values are row objects.
         */
        function parseSheetAsObjects(data, keyColumn) {
            if (!data || data.length < 2) return {};

            const headers = data[0].map(h => h.toString().trim());
            const keyIndex = headers.indexOf(keyColumn);
            if (keyIndex === -1) {
                throw new Error(`The required key column "${keyColumn}" was not found in the sheet.`);
            }

            const obj = {};
            const body = data.slice(1);
            body.forEach(row => {
                const key = row[keyIndex];
                if (key) {
                    const rowObj = {};
                    headers.forEach((header, index) => {
                        if (index === keyIndex) return; // Skip the key column itself

                        // Convert header to camelCase for consistency
                        const camelCaseHeader = header.replace(/\s(.)/g, ($1) => $1.toUpperCase()).replace(/\s/g, '').replace(/^(.)/, ($1) => $1.toLowerCase());
                        rowObj[camelCaseHeader] = row[index];
                    });
                    obj[key] = rowObj;
                }
            });
            return obj;
        }

        /**
         * Parses the raw casting schedule data.
         * @param {Array<Array<string>>} data The raw 2D array from the sheet.
         * @returns {Array<object>} An array of objects, where each object represents a cast.
         */
        function parseCastingSchedule(data, panelLegend) {
            if (!data || data.length < 2 || !panelLegend) return [];

            const panelIds = Object.keys(panelLegend);
            let bestMatch = { index: -1, score: 0 };

            // Find the row that is most likely the header row by checking for panel IDs
            data.forEach((row, index) => {
                if (!row) return;
                let score = 0;
                row.forEach(cell => {
                    if (cell && panelIds.includes(cell.toString().trim())) {
                        score++;
                    }
                });
                if (score > bestMatch.score) {
                    bestMatch = { index, score };
                }
            });

            let headerRowIndex = bestMatch.index;

            // Fallback to original logic if no good match is found (e.g., < 2 panel IDs in header)
            if (headerRowIndex === -1 || bestMatch.score < 2) {
                headerRowIndex = data.findIndex(row => row && row[0] && row[0].toString().trim().match(/^(Cast|Day)/i));
                if (headerRowIndex === -1) {
                    // If still no header, it's ambiguous. Fallback to assuming the first row.
                    headerRowIndex = 0;
                }
            }

            const headers = data[headerRowIndex].map(h => h ? h.toString().trim() : '');
            const scheduleData = data.slice(headerRowIndex + 1);
            const schedule = [];

            scheduleData.forEach(row => {
                if (!row || row.every(cell => !cell || cell.toString().trim() === '')) return;

                // Heuristic to prevent misinterpreting data rows as schedule rows
                const firstCol = row[0] ? row[0].toString().trim() : '';
                if (panelIds.includes(firstCol)) {
                    return; // Skip rows that start with a Panel ID, likely not a cast definition
                }

                const cast = {};
                for (let i = 1; i < headers.length; i++) {
                    const panelId = headers[i];
                    const qty = row[i];
                    if (panelId && qty && !isNaN(parseInt(qty, 10)) && parseInt(qty, 10) > 0) {
                        cast[panelId] = parseInt(qty, 10);
                    }
                }
                if (Object.keys(cast).length > 0) {
                    schedule.push(cast);
                }
            });
            return schedule;
        }


        /**
         * Processes the raw data from `loadDataFromActiveSheet`. It parses the raw data arrays,
         * validates the essential `panelLegend`, stores all data in the global `appState`,
         * and then calls `displayReviewData` to show the parsed information for confirmation.
         * @param {{projectInfoData: object, panelLegendData: object, castingScheduleData: object, projectInfoForSchedule: object}} rawData The raw data object from Code.gs.
         */
        function processData(rawData) {
            const { projectInfoData, panelLegendData, castingScheduleData, projectInfoForSchedule } = rawData;

            const projectInfo = parseSheetAsKeyValue(projectInfoData);

            // --- MODIFICATION START: Extract headers before parsing ---
            let panelLegendHeaders = [];
            if (panelLegendData && panelLegendData.length > 0) {
                const rawHeaders = panelLegendData[0].map(h => h.toString().trim());
                const panelIdIndex = rawHeaders.indexOf('Panel ID');
                if (panelIdIndex !== -1) {
                    // Store headers in original order, excluding 'Panel ID'
                    panelLegendHeaders = rawHeaders.filter((_, index) => index !== panelIdIndex);
                } else {
                    // Fallback if 'Panel ID' is not found, just use all but the first column
                    panelLegendHeaders = rawHeaders.slice(1);
                }
            }
            // --- MODIFICATION END ---

            const panelLegend = parseSheetAsObjects(panelLegendData, 'Panel ID');
            
            let castingSchedule = [];
            // Prefer the dedicated "Casting Schedule" sheet if it exists and has data.
            if (castingScheduleData && castingScheduleData.length > 1) {
                castingSchedule = parseCastingSchedule(castingScheduleData, panelLegend);
            }
            // Otherwise, fall back to checking the project info data for a schedule.
            else if (projectInfoForSchedule && projectInfoForSchedule.length > 1) {
                castingSchedule = parseCastingSchedule(projectInfoForSchedule, panelLegend);
            }

            if (!panelLegend || Object.keys(panelLegend).length === 0) {
                const friendlyMessage = `Could not process the "Panel Legend" data.

This usually happens for one of these reasons:
1.  The sheet name in your Google Sheet is not exactly "Panel Legend" (it's case-sensitive).
2.  The "Panel Legend" sheet does not contain a column header named exactly "Panel ID".
3.  The sheet is empty.

Please verify the sheet structure and try again.
`;
                alert(friendlyMessage);
                console.error("Panel Legend processing failed. Received raw data:", rawData);
                return;
            }

            appState.panelLegend = panelLegend;
            appState.panelLegendHeaders = panelLegendHeaders;
            appState.castingSchedule = castingSchedule;
            appState.projectInfo = projectInfo;
            let projectName = 'N/A';
            if (projectInfo) {
                // Find the project name key case-insensitively to make it more robust.
                const projectNameKey = Object.keys(projectInfo).find(key => key.toLowerCase().includes('project') && key.toLowerCase().includes('name'));
                if (projectNameKey && projectInfo[projectNameKey]) {
                    projectName = projectInfo[projectNameKey];
                }
            }
            appState.projectName = projectName;
            displayReviewData();
        }


        // =================================================================================
        // MODULE: CORE SCHEDULING LOGIC
        // The main algorithm for optimizing form reuse.
        // =================================================================================

        function generateSchedule(panelLegend, castingSchedule) {
            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = ''; // Clear previous content

            if (!castingSchedule || castingSchedule.length === 0) {
                outputDiv.innerHTML = '<h2>Casting Schedule</h2><p>No casting schedule data available to display.</p>';
                return;
            }

            let fullOutput = `<h2>Casting Schedule</h2>
            <p>This schedule displays the casting plan directly from the "Casting Schedule" tab in the Google Sheet.</p>`;

            castingSchedule.forEach((cast, castIndex) => {
                const castNumber = castIndex + 1;
                fullOutput += `<div class="cast-schedule-print-container">`;
                fullOutput += `<h3>Cast ${castNumber}</h3>`;
                fullOutput += `
                    <table class="schedule-table">
                        <thead>
                            <tr>
                                <th>Panel ID</th>
                                <th>Quantity</th>
                                <th>Length</th>
                                <th>Width</th>
                                <th>Thickness</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                const sortedPanelIds = Object.keys(cast).sort();
                for (const panelId of sortedPanelIds) {
                    const qty = cast[panelId];
                    const panelDetails = panelLegend[panelId] || {};
                    fullOutput += `
                        <tr>
                            <td><strong>${panelId}</strong></td>
                            <td>${qty}</td>
                            <td>${panelDetails.length || 'N/A'}</td>
                            <td>${panelDetails.width || 'N/A'}</td>
                            <td>${panelDetails.thickness || 'N/A'}</td>
                        </tr>
                    `;
                }

                fullOutput += `</tbody></table></div>`;
            });

            outputDiv.innerHTML = fullOutput;

            // Update UI controls
            document.getElementById('print-schedule-button').disabled = false;
            document.getElementById('print-note').style.display = 'inline';
            document.getElementById('generate-stickers-button').disabled = false;
            document.getElementById('generate-tracking-sheet-button').disabled = false;
            document.getElementById('view-layout-button').disabled = false; // Layout visualization is now enabled
        }


        // =================================================================================
        // MODULE: UI & OUTPUT GENERATION
        // Functions for updating the DOM, displaying results, and handling UI views.
        // =================================================================================

        /**
         * Renders the data parsed from the uploaded file into HTML tables within the review container.
         * This allows the user to verify that their data was read correctly before proceeding.
         */
        function displayReviewData() {
            const { panelLegend, castingSchedule, panelLegendHeaders } = appState;
            const legendDiv = document.getElementById('review-panel-legend');
            const scheduleDiv = document.getElementById('review-casting-schedule');
 
            // Dynamically generate Panel Legend table
            if (panelLegend && Object.keys(panelLegend).length > 0) {
                // --- START: Dynamic Header Generation from appState ---
                // Convert original headers to camelCase to match the keys in the panelLegend objects
                const camelCaseHeaders = panelLegendHeaders.map(h =>
                    h.replace(/\s(.)/g, ($1) => $1.toUpperCase())
                     .replace(/\s/g, '')
                     .replace(/^(.)/, ($1) => $1.toLowerCase())
                );

                let legendHtml = '<table><thead><tr>';
                legendHtml += '<th>Panel ID</th>'; // First header is always Panel ID
                panelLegendHeaders.forEach(header => {
                    legendHtml += `<th>${header}</th>`; // Use original header names from the sheet
                });
                legendHtml += '</tr></thead><tbody>';

                // Sort panel IDs for consistent row ordering
                const sortedPanelIds = Object.keys(panelLegend).sort();

                for (const id of sortedPanelIds) {
                    const panel = panelLegend[id];
                    legendHtml += `<tr>`;
                    legendHtml += `<td><strong>${id}</strong></td>`;
                    // Iterate through the camelCase headers to fetch data in the correct order
                    camelCaseHeaders.forEach(key => {
                        legendHtml += `<td>${panel[key] || ''}</td>`;
                    });
                    legendHtml += `</tr>`;
                }
                legendHtml += '</tbody></table>';
                legendDiv.innerHTML = legendHtml;
            } else {
                legendDiv.innerHTML = '<p>No panel legend data found.</p>';
            }

            // Generate Casting Schedule table (logic remains the same)
            let scheduleHtml = '';
            if (castingSchedule && castingSchedule.length > 0) {
                scheduleHtml = '<table><tr><th style="width:10%;">Cast #</th><th>Panels (Qty)</th></tr>';
                castingSchedule.forEach((cast, index) => {
                    const panelList = Object.entries(cast)
                        .map(([panelId, qty]) => `${panelId}: ${qty}`)
                        .join(', ');
                    scheduleHtml += `<tr><td>${index + 1}</td><td>${panelList}</td></tr>`;
                });
                scheduleHtml += '</table>';
            } else {
                scheduleHtml = `<p style="color: var(--text-secondary); border: 1px dashed var(--border-color); padding: 1rem; border-radius: 0.5rem;">
                    No casting schedule data was found. Please ensure:
                    <ul style="margin-top: 0.5rem; padding-left: 1.5rem;">
                        <li>A sheet named "Casting Schedule" exists, OR</li>
                        <li>The schedule data is present in the "Project Information" sheet.</li>
                        <li>The schedule table has a header row starting with "Cast #" or "Day".</li>
                    </ul>
                </p>`;
            }
            scheduleDiv.innerHTML = scheduleHtml;

            // Display project info (logic remains the same)
            const projectInfoDiv = document.getElementById('review-project-info');
            if (appState.projectInfo && Object.keys(appState.projectInfo).length > 0) {
                let projectInfoHtml = '<table style="width:100%; border-collapse: collapse;">';
                for (const key in appState.projectInfo) {
                    const value = (appState.projectInfo[key] || '').replace(/\n/g, '<br>');
                    projectInfoHtml += `<tr style="border-bottom: 1px solid var(--border-color);"><th style="padding: 8px; text-align: left; width: 30%;">${key}</th><td style="padding: 8px; text-align: left;">${value}</td></tr>`;
                }
                projectInfoHtml += '</table>';
                projectInfoDiv.innerHTML = projectInfoHtml;
            } else {
                projectInfoDiv.innerHTML = '<p>No project information found in the uploaded file.</p>';
            }

            // Show review container using the new navigation module
            Navigation.showView('#review-container');
        }

        /**
         * Generates and displays printable stickers for each individual panel instance.
         * It calculates unique IDs for every panel, reads layout settings from the UI,
         * and dynamically creates the sticker HTML and CSS for printing.
         */
        function generateStickers() {
             const { panelLegend, castingSchedule, projectName } = appState;
             // Read layout settings from the form
             const settings = {
                 width: parseFloat(document.getElementById('sticker-width').value),
                 height: parseFloat(document.getElementById('sticker-height').value),
                 cols: parseInt(document.getElementById('sticker-cols').value, 10),
                 rows: parseInt(document.getElementById('sticker-rows').value, 10),
                 marginTop: parseFloat(document.getElementById('sheet-margin-top').value),
                 marginLeft: parseFloat(document.getElementById('sheet-margin-left').value),
                 gapV: parseFloat(document.getElementById('gap-vertical').value),
                 gapH: parseFloat(document.getElementById('gap-horizontal').value)
             };
             const stickersPerPage = settings.cols * settings.rows;
             // Generate unique panel IDs
             let panelInstanceCounter = {};
             const allPanelsWithUniqueIds = [];
             castingSchedule.forEach(cast => {
                 const sortedPanelIds = Object.keys(cast).sort();
                 for (const panelId of sortedPanelIds) {
                     for (let i = 0; i < cast[panelId]; i++) {
                         if (!panelInstanceCounter[panelId]) {
                             panelInstanceCounter[panelId] = 0;
                         }
                         panelInstanceCounter[panelId]++;
                         const uniqueId = `${panelId}.${String(panelInstanceCounter[panelId]).padStart(2, '0')}`;
                         allPanelsWithUniqueIds.push({ panelId, uniqueId });
                     }
                 }
             });
             // --- Dynamic CSS for sticker layout ---
             const existingStyle = document.getElementById('dynamic-sticker-style');
             if (existingStyle) existingStyle.remove();
             const style = document.createElement('style');
             style.id = 'dynamic-sticker-style';
             style.innerHTML = `
                @media print {
                    @page sticker-page {
                        size: letter portrait;
                        margin: ${settings.marginTop}in ${settings.marginLeft}in;
                    }
                    .sticker-sheet {
                        box-shadow: none !important;
                        border: none !important;
                    }
                    .sticker {
                        border: 1px solid #000 !important;
                    }
                }
                 .sticker-sheet {
                     display: grid;
                     grid-template-columns: repeat(${settings.cols}, ${settings.width}in);
                     grid-template-rows: repeat(${settings.rows}, ${settings.height}in);
                     gap: ${settings.gapV}in ${settings.gapH}in;
                     width: calc(${settings.cols} * ${settings.width}in + (${settings.cols} - 1) * ${settings.gapH}in);
                     padding: 20px; /* Padding for on-screen view only */
                     margin: auto; /* Center on screen */
                     background-color: #fff;
                     box-shadow: var(--shadow-lg);
                     page-break-after: always;
                 }
                 .sticker-sheet:last-of-type {
                     page-break-after: avoid;
                 }
                 .sticker {
                     width: ${settings.width}in;
                     height: ${settings.height}in;
                     border: 1px solid #ccc; /* Visual guide for screen */
                     box-sizing: border-box;
                     padding: 4px;
                     font-size: 7pt;
                     color: #000;
                     overflow: hidden;
                     display: flex;
                     flex-direction: column;
                     justify-content: space-between;
                 }
             `;
             document.head.appendChild(style);
             const stickerContainer = document.getElementById('sticker-sheets-output');
             stickerContainer.innerHTML = ''; // Clear previous content
             // Create and populate sticker sheets
             for (let i = 0; i < allPanelsWithUniqueIds.length; i += stickersPerPage) {
                 const sheetPanels = allPanelsWithUniqueIds.slice(i, i + stickersPerPage);
                 const stickerSheet = document.createElement('div');
                 stickerSheet.className = 'sticker-sheet';
                 sheetPanels.forEach(({ panelId, uniqueId }) => {
                     const panel = panelLegend[panelId];
                     if (!panel) return;
                     const sticker = document.createElement('div');
                     sticker.className = 'sticker';
                     sticker.innerHTML = `
                         <div class="sticker-header">
                             <span>${projectName}</span>
                             <span><strong>${uniqueId}</strong></span>
                         </div>
                         <div class="sticker-body">
                             <div class="sticker-dims">
                                 L: ${panel.length || 'N/A'} | W: ${panel.width || 'N/A'} | T: ${panel.thickness || 'N/A'}
                             </div>
                             <div class="qc-boxes">
                                 <div class="qc-box">M</div>
                                 <div class="qc-box">F</div>
                                 <div class="qc-box">C</div>
                                 <div class="qc-box">W</div>
                             </div>
                         </div>
                         <div class="sticker-footer">
                             <span>${panel.finish || ''}</span>
                             <span>${panel.color || ''}</span>
                         </div>
                     `;
                     stickerSheet.appendChild(sticker);
                 });
                 stickerContainer.appendChild(stickerSheet);
             }
             // Update UI using the new navigation module
             Navigation.showView('#sticker-sheet-container');
             document.getElementById('sticker-settings-details').open = false; // Close settings after generating
        }

        /**
         * Generates a printable tracking sheet organized by cast.
         * This sheet provides a checklist for quality control at various production stages for each unique panel.
         */
        function generateTrackingSheet() {
            const { panelLegend, castingSchedule, projectName } = appState;
            if (!panelLegend || !castingSchedule) {
                alert('Please generate a schedule first.');
                return;
            }
            const trackingContainer = document.getElementById('tracking-sheet-container');
            trackingContainer.innerHTML = ''; // Clear previous content
            let panelInstanceCounter = {};
            let fullHtml = `<h2>Tracking Sheets</h2>
            <p>These sheets provide a detailed record for quality control and tracking of each panel throughout the production process.</p>`;
            castingSchedule.forEach((cast, castIndex) => {
                const castNumber = castIndex + 1;
                fullHtml += `<div class="tracking-sheet-print-container">`;
                fullHtml += `<h3>Cast ${castNumber}</h3>`;
                fullHtml += `<table class="schedule-table">
                    <thead>
                        <tr>
                            <th>Panel Unique ID</th>
                            <th>Mill QC</th>
                            <th>Formout QC</th>
                            <th>Casting QC</th>
                            <th>Wash QC</th>
                            <th>Seal QC</th>
                            <th>Crate QC</th>
                            <th>Pack QC</th>
                        </tr>
                    </thead>
                    <tbody>`;
                const sortedPanelIds = Object.keys(cast).sort();
                for (const panelId of sortedPanelIds) {
                    for (let i = 0; i < cast[panelId]; i++) {
                        if (!panelInstanceCounter[panelId]) {
                            panelInstanceCounter[panelId] = 0;
                        }
                        panelInstanceCounter[panelId]++;
                        const uniqueId = `${panelId}.${String(panelInstanceCounter[panelId]).padStart(2, '0')}`;
                        fullHtml += `<tr>
                            <td><strong>${uniqueId}</strong></td>
                            <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
                        </tr>`;
                    }
                }
                fullHtml += `</tbody></table></div>`;
            });
            trackingContainer.innerHTML = fullHtml;
            // Update UI using the new navigation module
            Navigation.showView('#tracking-sheet-container');
        }


        // =================================================================================
        // MODULE: CASTING LAYOUT VISUALIZATION (INTERACTIVE)
        // =================================================================================

        /**
         * Populates the cast selector dropdown.
         */
        // No longer needed as all casts are displayed at once.
        function populateCastSelector() {}

        /**
         * Initializes the layout for a given cast. If a layout doesn't exist, it creates a default one.
         */
        function initializeLayoutForCast(castIndex) {
            if (layoutState.layouts[castIndex]) {
                return; // Already initialized
            }

            const { castingSchedule, panelLegend } = appState;
            const castData = castingSchedule[castIndex];
            if (!castData) return;

            const forms = [];
            let panelInstanceCounter = {};
            const sortedPanelIds = Object.keys(castData).sort();
            sortedPanelIds.forEach(panelId => {
                if (!panelInstanceCounter[panelId]) panelInstanceCounter[panelId] = 0;
                for (let i = 0; i < castData[panelId]; i++) {
                    panelInstanceCounter[panelId]++;
                    const uniqueId = `${panelId}.${String(panelInstanceCounter[panelId]).padStart(2, '0')}`;
                    const offsetInput = document.getElementById('form-offset-input');
                    const offset = parseFloat(offsetInput.value) || 0;
                    const baseWidth = parseDim(panelLegend[panelId].width);
                    const baseLength = parseDim(panelLegend[panelId].length);

                    forms.push({
                        id: uniqueId,
                        panelId: panelId,
                        x: 0, // Initial position in inches
                        y: 0,
                        rotation: 0, // In degrees
                        width: baseWidth > 0 ? baseWidth + (2 * offset) : 0,
                        length: baseLength > 0 ? baseLength + (2 * offset) : 0
                    });
                }
            });

            // Auto-pack forms for the initial layout
            const packedForms = autoPackForms(forms, layoutState.panelDimensions.length, layoutState.panelDimensions.width);

            layoutState.layouts[castIndex] = {
                forms: packedForms,
                panelDimensions: { ...layoutState.panelDimensions }
            };
        }
        
        /**
         * A simple packing algorithm to provide a default layout.
         */
        function autoPackForms(forms, panelLength, panelWidth) {
            const areaKey = layoutState.selectedCastingArea;
            let formsToPack = [...forms];
            const packedForms = [];

            if (areaKey === 'presetA') {
                const area = castingAreas.presetA;
                let tableOffsetY = 0;
                const gap = 40;
                area.tables.forEach(table => {
                    let currentX = 5;
                    let currentY = tableOffsetY + 5;
                    let maxYinRow = 0;
                    const remainingFormsForNextTable = [];

                    formsToPack.forEach(form => {
                        if (currentX + form.length > table.length) {
                            currentX = 5;
                            currentY += maxYinRow + 5;
                            maxYinRow = 0;
                        }
                        if (currentY + form.width <= tableOffsetY + table.width) {
                            packedForms.push({ ...form, x: currentX, y: currentY });
                            currentX += form.length + 5;
                            if (form.width > maxYinRow) maxYinRow = form.width;
                        } else {
                            remainingFormsForNextTable.push(form);
                        }
                    });
                    formsToPack = remainingFormsForNextTable;
                    tableOffsetY += table.width + gap;
                });
                return packedForms;
            } else if (areaKey === 'presetB') {
                 const area = castingAreas.presetB;
                 const cols = 4;
                 const gap = 10;
                 const tableTemplate = area.tables[0]; // Now rotated: 120x60
                 const tablesToPackOn = Array.from({ length: 8 }, (_, i) => {
                     const col = i % cols;
                     const row = Math.floor(i / cols);
                     return {
                         ...tableTemplate,
                         offsetX: col * (tableTemplate.length + gap),
                         offsetY: row * (tableTemplate.width + gap)
                     };
                 });

                 tablesToPackOn.forEach(table => {
                     let currentX = table.offsetX + 5;
                     let currentY = table.offsetY + 5;
                     let maxYinRow = 0;
                     const remainingFormsForNextTable = [];

                     formsToPack.forEach(form => {
                         // Attempt to fit rotated form first if it's better
                         const canFitOriginal = currentX + form.length <= table.offsetX + table.length && currentY + form.width <= table.offsetY + table.width;
                         const canFitRotated = currentX + form.width <= table.offsetX + table.length && currentY + form.length <= table.offsetY + table.width;

                         if (canFitRotated && (!canFitOriginal || form.width < form.length)) {
                             // Rotate the form if it fits better or is the only way it fits
                             form.rotation = 90;
                             [form.length, form.width] = [form.width, form.length]; // Swap dimensions for packing
                         }

                         if (currentX + form.length > table.offsetX + table.length) {
                             currentX = table.offsetX + 5;
                             currentY += maxYinRow + 5;
                             maxYinRow = 0;
                         }

                         if (currentY + form.width <= table.offsetY + table.width) {
                             packedForms.push({ ...form, x: currentX, y: currentY });
                             currentX += form.length + 5;
                             if (form.width > maxYinRow) maxYinRow = form.width;
                         } else {
                             remainingFormsForNextTable.push(form);
                         }
                         // Revert dimensions if swapped for packing
                         if (form.rotation === 90) {
                            [form.length, form.width] = [form.width, form.length];
                         }
                     });
                     formsToPack = remainingFormsForNextTable;
                 });
                 return packedForms;
            } else { // custom
                // Original packing logic for custom area
                let currentX = 5;
                let currentY = 5;
                let maxYinRow = 0;
                return forms.map(form => {
                    if (currentX + form.length > panelLength) {
                        currentX = 5;
                        currentY += maxYinRow + 5;
                        maxYinRow = 0;
                    }
                    const packedForm = { ...form, x: currentX, y: currentY };
                    currentX += form.length + 5;
                    if (form.width > maxYinRow) maxYinRow = form.width;
                    return packedForm;
                });
            }
        }


        /**
         * Main drawing function for the interactive canvas.
         */
        function drawCastingLayout(castIndex, canvas) {
            const { panelLegend } = appState;
            const ctx = canvas.getContext('2d');
            const wrapper = canvas.parentElement; // The canvas-wrapper div
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;

            const currentLayout = layoutState.layouts[castIndex];
            if (!currentLayout) {
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = '16px sans-serif';
                ctx.fillText('No layout data for this cast.', canvas.width / 2, canvas.height / 2);
                return;
            }

            const { forms, panelDimensions } = currentLayout;
            const { length: panelLength, width: panelWidth } = panelDimensions;

            const padding = 50;
            const scaleX = (canvas.width - padding * 2) / panelLength;
            const scaleY = (canvas.height - padding * 2) / panelWidth;
            const scale = Math.min(scaleX, scaleY);

            const panelPixelWidth = panelLength * scale;
            const panelPixelHeight = panelWidth * scale;
            const panelX = (canvas.width - panelPixelWidth) / 2;
            const panelY = (canvas.height - panelPixelHeight) / 2;

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-main').trim();
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            ctx.lineWidth = 2;

            const areaKey = layoutState.selectedCastingArea;
            const drawLabels = () => {
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                if (areaKey === 'presetA') {
                    const area = castingAreas.presetA;
                    let tableOffsetY = 0;
                    const gap = 40;
                    area.tables.forEach((table, index) => {
                        const tableY = panelY + tableOffsetY * scale;
                        const label = `Table ${index + 1}: ${table.length / 12}' x ${table.width / 12}'`;
                        const textMetrics = ctx.measureText(label);
                        ctx.fillStyle = 'rgba(44, 62, 80, 0.75)'; // Semi-transparent background
                        ctx.fillRect(panelX, tableY, textMetrics.width + 10, 20);
                        ctx.fillStyle = '#ecf0f1';
                        ctx.fillText(label, panelX + 5, tableY + 3);
                        tableOffsetY += table.width + gap;
                    });
                } else if (areaKey === 'presetB') {
                    const area = castingAreas.presetB;
                    const table = area.tables[0];
                    const cols = 4;
                    const rows = 2;
                    const gap = 10;
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const tableIndex = row * cols + col;
                            const tableOffsetX = col * (table.length + gap);
                            const tableOffsetY = row * (table.width + gap);
                            const tableX = panelX + tableOffsetX * scale;
                            const tableY = panelY + tableOffsetY * scale;
                            const label = `Table ${tableIndex + 1}: ${table.length / 12}' x ${table.width / 12}'`;
                            const textMetrics = ctx.measureText(label);
                            ctx.fillStyle = 'rgba(44, 62, 80, 0.75)';
                            ctx.fillRect(tableX, tableY, textMetrics.width + 10, 20);
                            ctx.fillStyle = '#ecf0f1';
                            ctx.fillText(label, tableX + 5, tableY + 3);
                        }
                    }
                } else {
                    ctx.fillStyle = 'rgba(44, 62, 80, 0.75)';
                    const label = `Casting Area: ${panelLength}" x ${panelWidth}"`;
                    const textMetrics = ctx.measureText(label);
                    ctx.fillRect(panelX, panelY - 20, textMetrics.width + 10, 20);
                    ctx.fillStyle = '#ecf0f1';
                    ctx.fillText(label, panelX + 5, panelY - 17);
                }
            };

            if (areaKey === 'presetA') {
                const area = castingAreas.presetA;
                let tableOffsetY = 0;
                const gap = 40;
                area.tables.forEach(table => {
                    ctx.strokeRect(panelX, panelY + tableOffsetY * scale, table.length * scale, table.width * scale);
                    tableOffsetY += table.width + gap;
                });
            } else if (areaKey === 'presetB') {
                const area = castingAreas.presetB;
                const table = area.tables[0];
                const cols = 4;
                const rows = 2;
                const gap = 10;
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const tableOffsetX = col * (table.length + gap);
                        const tableOffsetY = row * (table.width + gap);
                        ctx.strokeRect(panelX + tableOffsetX * scale, panelY + tableOffsetY * scale, table.length * scale, table.width * scale);
                    }
                }
            } else {
                ctx.strokeRect(panelX, panelY, panelPixelWidth, panelPixelHeight);
            }

            forms.forEach(form => {
                const formPixelLength = form.length * scale;
                const formPixelWidth = form.width * scale;
                const formPixelX = panelX + form.x * scale;
                const formPixelY = panelY + form.y * scale;

                ctx.save();
                // Move the canvas origin to the center of where the form should be
                ctx.translate(formPixelX + formPixelLength / 2, formPixelY + formPixelWidth / 2);
                // Rotate the canvas around the new origin
                ctx.rotate(form.rotation * Math.PI / 180);

                // Set fill style based on selection
                ctx.fillStyle = form.id === layoutState.selectedFormId ? 'rgba(231, 76, 60, 0.8)' : 'rgba(52, 152, 219, 0.8)';
                
                // Draw the rectangle centered on the new origin
                ctx.fillRect(-formPixelLength / 2, -formPixelWidth / 2, formPixelLength, formPixelWidth);
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(-formPixelLength / 2, -formPixelWidth / 2, formPixelLength, formPixelWidth);

                // Draw the text centered on the new origin
                ctx.fillStyle = '#ecf0f1';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const fontSize = Math.max(8, Math.min(14, formPixelWidth / 2.5, formPixelLength / (form.panelId.length * 0.8)));
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.fillText(form.panelId, 0, 0);

                // Restore the canvas state to before the translation and rotation
                ctx.restore();
            });
            
            // Draw labels on top of forms
            drawLabels();
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function isPointInRotatedRect(point, form, panelOrigin, scale) {
            const formPixelLength = form.length * scale;
            const formPixelWidth = form.width * scale;
            const formPixelX = panelOrigin.x + form.x * scale;
            const formPixelY = panelOrigin.y + form.y * scale;

            const centerX = formPixelX + formPixelLength / 2;
            const centerY = formPixelY + formPixelWidth / 2;

            // Translate point to be relative to the rectangle's center
            const translatedX = point.x - centerX;
            const translatedY = point.y - centerY;

            // Rotate the point back
            const angleRad = -form.rotation * Math.PI / 180;
            const rotatedX = translatedX * Math.cos(angleRad) - translatedY * Math.sin(angleRad);
            const rotatedY = translatedX * Math.sin(angleRad) + translatedY * Math.cos(angleRad);

            // Check if the rotated point is inside the non-rotated rectangle
            return Math.abs(rotatedX) <= formPixelLength / 2 && Math.abs(rotatedY) <= formPixelWidth / 2;
        }

        function handleCanvasMouseDown(e) {
            const canvas = e.target;
            const castIndex = parseInt(canvas.dataset.castIndex, 10);
            if (isNaN(castIndex)) return;

            layoutState.activeCastIndex = castIndex; // Set the active cast

            const mousePos = getMousePos(canvas, e);
            const currentLayout = layoutState.layouts[castIndex];
            if (!currentLayout) return;

            const { forms, panelDimensions } = currentLayout;
            const { length: panelLength, width: panelWidth } = panelDimensions;
            const padding = 50;
            const scale = Math.min((canvas.width - padding * 2) / panelLength, (canvas.height - padding * 2) / panelWidth);
            const panelX = (canvas.width - (panelLength * scale)) / 2;
            const panelY = (canvas.height - (panelWidth * scale)) / 2;

            // Find which form was clicked (check in reverse order to select top-most)
            let clickedForm = null;
            for (let i = forms.length - 1; i >= 0; i--) {
                if (isPointInRotatedRect(mousePos, forms[i], {x: panelX, y: panelY}, scale)) {
                    clickedForm = forms[i];
                    break;
                }
            }

            if (clickedForm) {
                layoutState.selectedFormId = clickedForm.id;
                layoutState.isDragging = true;
                layoutState.isRotating = layoutState.rKeyDown;
                layoutState.dragStart.x = mousePos.x / scale - clickedForm.x;
                layoutState.dragStart.y = mousePos.y / scale - clickedForm.y;
                canvas.style.cursor = 'grabbing';
            } else {
                layoutState.selectedFormId = null;
            }
            drawCastingLayout(castIndex, canvas);
        }

        function handleCanvasMouseMove(e) {
            const canvas = e.target;
            const castIndex = parseInt(canvas.dataset.castIndex, 10);
            if (isNaN(castIndex)) return;

            const infoBox = document.getElementById('form-info-box');
            if (layoutState.isDragging && layoutState.selectedFormId) {
                const mousePos = getMousePos(canvas, e);
                const activeCastIndex = layoutState.activeCastIndex;
                const currentLayout = layoutState.layouts[activeCastIndex];
                if (!currentLayout) return;

                const form = currentLayout.forms.find(f => f.id === layoutState.selectedFormId);
                if (!form) return;

                const activeCanvas = document.querySelector(`.casting-canvas[data-cast-index="${activeCastIndex}"]`);
                if (!activeCanvas) return;

                const scale = Math.min(
                    (activeCanvas.width - 100) / currentLayout.panelDimensions.length,
                    (activeCanvas.height - 100) / currentLayout.panelDimensions.width
                );

                if (layoutState.isRotating) {
                    const centerX = form.x + form.length / 2;
                    const centerY = form.y + form.width / 2;
                    const mouseAngle = Math.atan2((mousePos.y / scale) - centerY, (mousePos.x / scale) - centerX);
                    form.rotation = mouseAngle * 180 / Math.PI;
                } else {
                    form.x = mousePos.x / scale - layoutState.dragStart.x;
                    form.y = mousePos.y / scale - layoutState.dragStart.y;
                }
                drawCastingLayout(activeCastIndex, activeCanvas);
            }

            // Info box logic - works on any hovered canvas
            const mousePos = getMousePos(canvas, e);
            const currentLayout = layoutState.layouts[castIndex];
            if (!currentLayout) {
                infoBox.style.display = 'none';
                return;
            }
            const { forms, panelDimensions } = currentLayout;
            const scale = Math.min((canvas.width - 100) / panelDimensions.length, (canvas.height - 100) / panelDimensions.width);
            const panelX = (canvas.width - (panelDimensions.length * scale)) / 2;
            const panelY = (canvas.height - (panelDimensions.width * scale)) / 2;

            let hoveredForm = null;
            for (let i = forms.length - 1; i >= 0; i--) {
                if (isPointInRotatedRect(mousePos, forms[i], {x: panelX, y: panelY}, scale)) {
                    hoveredForm = forms[i];
                    break;
                }
            }

            if (hoveredForm) {
                infoBox.style.display = 'block';
                infoBox.style.left = `${e.clientX + 15}px`;
                infoBox.style.top = `${e.clientY + 15}px`;
                infoBox.innerHTML = `
                    <strong>ID:</strong> ${hoveredForm.panelId}<br>
                    <strong>Dims:</strong> ${hoveredForm.length}" x ${hoveredForm.width}"<br>
                    <strong>Pos:</strong> (${hoveredForm.x.toFixed(1)}, ${hoveredForm.y.toFixed(1)})<br>
                    <strong>Rot:</strong> ${hoveredForm.rotation.toFixed(1)}°
                `;
            } else {
                infoBox.style.display = 'none';
            }
        }

        function handleCanvasMouseUp(e) {
            layoutState.isDragging = false;
            layoutState.isRotating = false;
            document.querySelectorAll('.casting-canvas').forEach(c => c.style.cursor = 'grab');
        }

        function handleKeyDown(e) {
            if (e.key.toLowerCase() === 'r') {
                layoutState.rKeyDown = true;
                if (layoutState.isDragging) {
                    layoutState.isRotating = true;
                }
            }
        }

        function handleKeyUp(e) {
            if (e.key.toLowerCase() === 'r') {
                layoutState.rKeyDown = false;
                layoutState.isRotating = false;
            }
        }

        function saveLayout() {
            const castIndex = layoutState.activeCastIndex;
            if (layoutState.layouts[castIndex]) {
                try {
                    const layoutToSave = JSON.stringify(layoutState.layouts[castIndex]);
                    localStorage.setItem(`castingLayout_${castIndex}`, layoutToSave);
                    alert(`Layout for Cast ${castIndex + 1} saved!`);
                } catch (error) {
                    alert('Error saving layout.');
                    console.error(error);
                }
            }
        }

        function loadLayout() {
            const castIndex = layoutState.activeCastIndex;
            try {
                const savedLayout = localStorage.getItem(`castingLayout_${castIndex}`);
                if (savedLayout) {
                    layoutState.layouts[castIndex] = JSON.parse(savedLayout);
                    // Update UI with loaded dimensions
                    const { length, width } = layoutState.layouts[castIndex].panelDimensions;
                    document.getElementById('panel-length-input').value = length;
                    document.getElementById('panel-width-input').value = width;
                    const canvas = document.querySelector(`.casting-canvas[data-cast-index="${castIndex}"]`);
                    if (canvas) drawCastingLayout(castIndex, canvas);
                    alert(`Layout for Cast ${castIndex + 1} loaded!`);
                } else {
                    alert(`No saved layout found for Cast ${castIndex + 1}.`);
                }
            } catch (error) {
                alert('Error loading layout.');
                console.error(error);
            }
        }

        function resetLayout() {
            const castIndex = layoutState.activeCastIndex;
            // Clear the saved state for this cast
            delete layoutState.layouts[castIndex];
            // Re-initialize it with default packing
            initializeLayoutForCast(castIndex);
            const canvas = document.querySelector(`.casting-canvas[data-cast-index="${castIndex}"]`);
            if (canvas) drawCastingLayout(castIndex, canvas);
        }

        function prepareAndPrint(containerId) {
            const body = document.body;
            const container = document.getElementById(containerId);
            if (!container) {
                console.error('Print container not found:', containerId);
                return;
            }

            // Add a class to the body and a data attribute to the container
            // so CSS can target the correct element to show.
            body.classList.add('printing');
            container.classList.add('printing-target');

            const onAfterPrint = () => {
                body.classList.remove('printing');
                container.classList.remove('printing-target');
                window.removeEventListener('afterprint', onAfterPrint);
            };

            window.addEventListener('afterprint', onAfterPrint);

            setTimeout(() => {
                window.print();
            }, 50);
        }

        function generatePrintableLayout() {
            const container = document.getElementById('printable-layout-container');
            container.innerHTML = ''; // Clear previous content
            let fullSvgContent = '';

            appState.castingSchedule.forEach((cast, castIndex) => {
                const currentLayout = layoutState.layouts[castIndex];
                if (!currentLayout) return;

                const { forms, panelDimensions } = currentLayout;
                const { length: panelLength, width: panelWidth } = panelDimensions;

                let svgContent = `<div class="printable-cast-layout">`;
                const titleFontSize = Math.max(48, panelWidth / 4) * 0.8;
                const titleAreaHeight = titleFontSize * 2.5; // Provides generous vertical space for the title.
                const viewBoxY = -titleAreaHeight;
                const viewBoxHeight = panelWidth + (2 * titleAreaHeight); // Creates symmetrical vertical padding around the casting area.

                svgContent += `<svg class="printable-svg" viewBox="-10 ${viewBoxY} ${panelLength + 20} ${viewBoxHeight}" xmlns="http://www.w3.org/2000/svg">`;
                svgContent += `<rect x="-10" y="${viewBoxY}" width="${panelLength + 20}" height="${viewBoxHeight}" fill="white" />`;

                const projectTitle = (appState.projectName && appState.projectName.toLowerCase() !== 'not available' && appState.projectName.toLowerCase() !== 'n/a') ? appState.projectName : 'Project Layout';
                // Position the title's baseline within the allocated title area.
                svgContent += `<text x="0" y="${viewBoxY + titleFontSize * 1.2}" font-family="sans-serif" font-size="${titleFontSize}" font-weight="bold" text-anchor="start" fill="black">${projectTitle} - Cast ${castIndex + 1}</text>`;

                // Draw tables first
                const areaKey = layoutState.selectedCastingArea;
                if (areaKey === 'presetA') {
                    const area = castingAreas.presetA;
                    let tableOffsetY = 0;
                    const gap = 40;
                    area.tables.forEach(table => {
                        svgContent += `<rect x="0" y="${tableOffsetY}" width="${table.length}" height="${table.width}" fill="none" stroke="black" stroke-width="0.25" />`;
                        tableOffsetY += table.width + gap;
                    });
                } else if (areaKey === 'presetB') {
                    const area = castingAreas.presetB;
                    const table = area.tables[0];
                    const cols = 4;
                    const rows = 2;
                    const gap = 10;
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const tableOffsetX = col * (table.length + gap);
                            const tableOffsetY = row * (table.width + gap);
                            svgContent += `<rect x="${tableOffsetX}" y="${tableOffsetY}" width="${table.length}" height="${table.width}" fill="none" stroke="black" stroke-width="0.25" />`;
                        }
                    }
                } else {
                    svgContent += `<rect x="0" y="0" width="${panelLength}" height="${panelWidth}" fill="none" stroke="black" stroke-width="0.25" />`;
                }

                forms.forEach(form => {
                    const { x, y, length, width, rotation, panelId } = form;
                    svgContent += `<g transform="translate(${x}, ${y}) rotate(${rotation}, ${length / 2}, ${width / 2})">`;
                    svgContent += `<rect x="0" y="0" width="${length}" height="${width}" fill="#f0f0f0" stroke="black" stroke-width="0.1" />`;
                    const fontSize = Math.min(width * 0.6, length / (panelId.length * 0.6), 12); // Increased font size
                    svgContent += `<text x="${length / 2}" y="${width / 2}" font-family="sans-serif" font-size="${fontSize}" text-anchor="middle" dominant-baseline="middle" fill="black">${panelId}</text>`;
                    svgContent += `</g>`;
                });

                svgContent += `</svg></div>`;
                fullSvgContent += svgContent;
            });

            container.innerHTML = fullSvgContent;
            prepareAndPrint('printable-layout-container');
        }


        function handleCastingAreaChange(event) {
            const selectedValue = event.target.value;
            layoutState.selectedCastingArea = selectedValue;
            const lengthInput = document.getElementById('panel-length-input');
            const widthInput = document.getElementById('panel-width-input');
            const updateButton = document.getElementById('update-panel-btn');

            if (selectedValue === 'presetA' || selectedValue === 'presetB') {
                const area = castingAreas[selectedValue];
                lengthInput.value = area.totalLength;
                widthInput.value = area.totalWidth;
                lengthInput.readOnly = true;
                widthInput.readOnly = true;
                updateButton.disabled = true;
                // This needs to trigger a full redraw sequence for all visible layouts
                layoutState.panelDimensions = { length: area.totalLength, width: area.totalWidth };
                
                document.querySelectorAll('.casting-canvas').forEach(canvas => {
                    const castIndex = parseInt(canvas.dataset.castIndex, 10);
                    if (layoutState.layouts[castIndex]) {
                        // Update each layout's dimensions and re-pack its forms
                        layoutState.layouts[castIndex].panelDimensions = { ...layoutState.panelDimensions };
                        const packedForms = autoPackForms(layoutState.layouts[castIndex].forms, area.totalLength, area.totalWidth);
                        layoutState.layouts[castIndex].forms = packedForms;
                        // Redraw this specific canvas
                        drawCastingLayout(castIndex, canvas);
                    }
                });

            }
        }


        // =================================================================================
        // MODULE: UTILITIES
        // =================================================================================
        const Utilities = (() => {
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const enterFullscreenIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="pointer-events: none;"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>`;
            const exitFullscreenIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="pointer-events: none;"><path d="M5.5 0a.5.5 0 0 1 .5.5v4A1.5 1.5 0 0 1 4.5 6h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5zm5 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 10 4.5v-4a.5.5 0 0 1 .5-.5zM0 10.5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 6 11.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zm10 0a.5.5 0 0 1 .5-.5h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 1 0v4A1.5 1.5 0 0 1 14.5 16h-4a.5.5 0 0 1-.5-.5z"/></svg>`;

            function toggleFullScreen() {
                if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                    const el = document.documentElement;
                    if (el.requestFullscreen) {
                        el.requestFullscreen();
                    } else if (el.msRequestFullscreen) {
                        el.msRequestFullscreen();
                    } else if (el.mozRequestFullScreen) {
                        el.mozRequestFullScreen();
                    } else if (el.webkitRequestFullscreen) {
                        el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    }
                }
            }

            function updateFullscreenButton() {
                if (!fullscreenBtn) return;
                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                    fullscreenBtn.innerHTML = exitFullscreenIcon;
                    fullscreenBtn.title = "Exit Fullscreen";
                } else {
                    fullscreenBtn.innerHTML = enterFullscreenIcon;
                    fullscreenBtn.title = "Enter Fullscreen";
                }
            }
            
            function init() {
                if(fullscreenBtn) {
                    fullscreenBtn.innerHTML = enterFullscreenIcon;
                    fullscreenBtn.addEventListener('click', toggleFullScreen);
                    document.addEventListener('fullscreenchange', updateFullscreenButton);
                    document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
                    document.addEventListener('mozfullscreenchange', updateFullscreenButton);
                    document.addEventListener('MSFullscreenChange', updateFullscreenButton);
                }
            }

            return {
                init,
                toggleFullScreen
            };
        })();

        // =================================================================================
        // MODULE: EVENT LISTENERS & UI HANDLERS
        // =================================================================================


        /**
         * Resets the entire application UI to its initial state. This is used by the
         * "Start Over" button to clear all data and return to the file upload screen.
         */
        function resetToInitialView() {
            location.reload();
        }

        // --- Event Listener Setup ---
        // This function runs once the entire HTML document has been loaded and parsed.
        // It's the main entry point for attaching all the interactive event handlers.
        document.addEventListener('DOMContentLoaded', () => {
            // Main Actions
            // Automatically load data from the sheet when the app starts.
            loadDataFromActiveSheet();
            Utilities.init();
            document.getElementById('confirm-generate').addEventListener('click', () => {
                generateSchedule(appState.panelLegend, appState.castingSchedule);
                Navigation.showView('#output');
            });

            // Navigation & View Changes
            document.getElementById('back-to-review-button').addEventListener('click', () => {
                Navigation.showView('#review-container');
            });
            
            document.getElementById('back-to-schedule-button').addEventListener('click', () => {
               Navigation.showView('#output');
               const stickerStyle = document.getElementById('dynamic-sticker-style');
               if(stickerStyle) stickerStyle.remove();
           });

            document.getElementById('view-layout-button').addEventListener('click', () => {
                Navigation.showView('#casting-layout-container');
                
                const layoutsWrapper = document.getElementById('layouts-wrapper');
                layoutsWrapper.innerHTML = ''; // Clear previous layouts

                // Trigger change event to set initial state from dropdown
                handleCastingAreaChange({ target: document.getElementById('casting-area-selector') });

                appState.castingSchedule.forEach((cast, castIndex) => {
                    initializeLayoutForCast(castIndex);

                    // Create a container for each cast's title and canvas
                    const castView = document.createElement('div');
                    castView.className = 'cast-view';
                    castView.style.marginBottom = '40px';

                    const title = document.createElement('h3');
                    title.textContent = `Cast ${castIndex + 1}`;
                    title.style.borderBottom = '2px solid var(--accent-color)';
                    title.style.paddingBottom = '10px';
                    
                    const newCanvasWrapper = document.createElement('div');
                    newCanvasWrapper.className = 'canvas-wrapper';

                    const newCanvas = document.createElement('canvas');
                    newCanvas.className = 'casting-canvas';
                    newCanvas.dataset.castIndex = castIndex; // Store index for event handling
                    
                    newCanvasWrapper.appendChild(newCanvas);
                    castView.appendChild(title);
                    castView.appendChild(newCanvasWrapper);
                    layoutsWrapper.appendChild(castView);

                    drawCastingLayout(castIndex, newCanvas);

                    // Add event listeners to the new canvas
                    newCanvas.addEventListener('mousedown', handleCanvasMouseDown);
                    newCanvas.addEventListener('mousemove', handleCanvasMouseMove);
                    newCanvas.addEventListener('mouseup', handleCanvasMouseUp);
                    newCanvas.addEventListener('mouseleave', handleCanvasMouseUp);
                });
            });

            document.getElementById('casting-area-selector').addEventListener('change', handleCastingAreaChange);

            document.getElementById('form-offset-input').addEventListener('change', () => {
                // When offset changes, invalidate all current layouts so they are recalculated
                layoutState.layouts = {};
                // If the layout container is visible, simulate a click on the view button to refresh it
                if (document.getElementById('casting-layout-container').style.display === 'block') {
                    document.getElementById('view-layout-button').click();
                }
            });

            // New listeners for interactive layout
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            document.getElementById('save-layout-btn').addEventListener('click', saveLayout);
            document.getElementById('load-layout-btn').addEventListener('click', loadLayout);
            document.getElementById('reset-layout-btn').addEventListener('click', resetLayout);
            document.getElementById('print-layout-btn').addEventListener('click', generatePrintableLayout);

            // Output Generation
            document.getElementById('print-schedule-button').addEventListener('click', () => prepareAndPrint('output'));
            
            document.getElementById('generate-stickers-button').addEventListener('click', () => {
                if (!appState.panelLegend || !appState.castingSchedule) {
                    alert('Please generate a schedule first.');
                    return;
                }
                // Directly generate stickers, as the function now handles UI updates.
                generateStickers();
            });

            // The 'toggle-sticker-settings-btn' has been replaced by a <details> element, so its listener is no longer needed.

            document.getElementById('confirm-generate-stickers').addEventListener('click', generateStickers);
            
            document.getElementById('cancel-sticker-settings').addEventListener('click', () => {
                // Just close the settings <details> element.
                document.getElementById('sticker-settings-details').open = false;
            });

            document.getElementById('generate-tracking-sheet-button').addEventListener('click', generateTrackingSheet);
        });
    </script>
    </div>
</body>
</html> 