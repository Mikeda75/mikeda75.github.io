<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel Form Reuse Schedule Generator</title>
    <style>
        :root {
            --dark-bg: #2c3e50;
            --light-bg: #34495e;
            --text-color: #ecf0f1;
            --border-color: #7f8c8d;
            --accent-color: #3498db;
            --header-bg: #4a627a;
            --disabled-bg: #566573;
            --disabled-text: #95a5a6;
            --success-color: #27ae60;
            --success-hover: #229954;
        }
        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding: 20px;
            background-color: var(--dark-bg);
            color: var(--text-color);
        }
        #output {
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-top: 20px;
            white-space: pre-wrap; /* To respect markdown formatting */
            background-color: var(--light-bg);
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: var(--header-bg);
        }
        h1, h2, h3, h4 {
            color: var(--text-color);
        }
        h3 {
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 5px;
        }
        hr {
            border: 0;
            border-top: 1px solid var(--border-color);
        }
        #review-container {
            display: none;
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-top: 20px;
            background-color: var(--light-bg);
        }
        #header-container {
            position: sticky;
            top: 0;
            background-color: var(--dark-bg);
            padding: 20px 20px 10px 20px;
            margin: -20px -20px 0 -20px;
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            position: relative; /* For positioning the button */
        }
        #review-actions {
            display: none; /* Hidden by default */
            position: sticky;
            top: 120px; /* Fallback, will be set by JS */
            background-color: var(--light-bg);
            padding: 10px 20px;
            margin: 0 -20px 15px -20px; /* Counteract body padding */
            border-bottom: 1px solid var(--border-color);
            z-index: 99;
            justify-content: space-between;
            align-items: center;
        }
        #output-controls {
            background-color: var(--light-bg);
            border-bottom: 1px solid var(--border-color);
        }
        .input-option {
            margin-bottom: 20px;
        }
        .paste-area {
            margin-top: 10px;
        }
        .paste-area label {
            display: block;
            margin-bottom: 5px;
        }
        .paste-area textarea, .paste-area input[type="number"], .paste-area input[type="text"] {
            width: 98%;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--light-bg);
            color: var(--text-color);
        }
        ::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */
            color: var(--border-color);
            opacity: 1; /* Firefox */
        }
        .action-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
        }
        button {
            background-color: var(--accent-color);
            color: var(--text-color);
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover {
            filter: brightness(110%);
        }
        #generate-schedule {
            padding: 15px 25px;
            font-size: 1.1em;
            font-weight: bold;
            background-color: var(--success-color);
        }
        #generate-schedule:hover {
            background-color: var(--success-hover);
        }
        #generate-schedule:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            cursor: not-allowed;
        }
        .form-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .form-row span {
            margin-right: 10px;
            width: 60px;
        }
        .form-row input {
            width: 100px;
            margin-right: 10px;
        }
        #add-form-row {
            margin-top: 10px;
        }
        .template-link-container {
            margin-top: 15px;
        }
        .template-link {
            text-decoration: none;
            padding: 8px 12px;
            background-color: var(--light-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .template-link:hover {
            background-color: var(--header-bg);
            color: var(--text-color);
        }
       /* Sticker Styles */
       .sticker-sheet-container {
           display: none; /* Hidden by default */
           padding: 20px;
       }
       .sticker-sheet {
           display: flex;
           flex-wrap: wrap;
           gap: 0; /* No gap for printing */
           width: 8.5in;
           min-height: 11in;
           margin: auto;
           background-color: #fff; /* White background for the sheet */
           box-shadow: 0 0 10px rgba(0,0,0,0.1);
       }
       .sticker {
           box-sizing: border-box;
           width: 2in;
           height: 1in;
           border: 1px solid #ccc;
           padding: 4px;
           font-size: 7pt;
           color: #000;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           justify-content: space-between;
       }
       .sticker-header {
           display: flex;
           justify-content: space-between;
           font-weight: bold;
       }
       .sticker-dims {
           font-size: 6.5pt;
       }
       .sticker-body {
           flex-grow: 1;
           display: flex;
           flex-direction: column;
           justify-content: center;
       }
       .sticker-footer {
           display: flex;
           justify-content: space-between;
           font-size: 6.5pt;
       }
       .qc-boxes {
           display: flex;
           justify-content: space-around;
           margin-top: 3px;
       }
       .qc-box {
           border: 1px solid #000;
           width: 12px;
           height: 12px;
           font-size: 6pt;
           text-align: center;
           line-height: 10px;
       }
        @media print {
           body {
               padding: 0;
               margin: 0;
               font-size: 10pt;
               background-color: #fff !important;
               color: #000 !important;
           }
           * {
               color: #000 !important;
               background-color: #fff !important;
           }

           /* Hide all UI elements and containers that are not the main content */
           #header-container, #review-actions, #review-container, #output-controls, #input-container, .explanation-section, #print-note {
               display: none !important;
           }

            /* Hide the main content divs by default for printing */
            #output, #sticker-sheet-container, #tracking-sheet-container {
                display: none !important;
            }

            /* Only show the one that is currently visible on the screen */
            #output[style*="display: block"],
            #sticker-sheet-container[style*="display: block"],
            #tracking-sheet-container[style*="display: block"] {
                display: block !important;
                border: none;
                padding: 0;
                margin: 0;
                white-space: normal;
            }

           h3, h4 {
               page-break-after: avoid;
               font-size: 12pt;
           }
           table.schedule-table {
               width: 100% !important;
               font-size: 8pt;
               border-collapse: collapse;
           }
           .schedule-table tr {
               page-break-inside: avoid;
           }
           .schedule-table th, .schedule-table td {
               padding: 2px 4px;
               border: 1px solid #000 !important;
           }
           .schedule-table th {
                background-color: #eee !important;
           }

           /* Schedule-specific print styles */
            .cast-schedule-print-container {
                page-break-after: always;
                page-break-inside: avoid;
            }
            #output .cast-schedule-print-container:last-of-type {
                page-break-after: avoid;
            }
            @page schedule-page {
               size: letter landscape;
               margin: 0.25in;
            }
            #output {
                page: schedule-page;
            }

           /* Sticker-specific print styles */
           .sticker-sheet {
               width: 100%;
               height: 100%;
               box-shadow: none;
               gap: 0;
           }
           .sticker {
                border: 1px solid #000;
                page-break-inside: avoid;
           }
           @page sticker-page {
               size: letter portrait;
               margin: 0.25in;
           }
           .sticker-sheet-container {
               page: sticker-page;
           }

        }
           /* Tracking Sheet-specific print styles */
           .tracking-sheet-print-container {
               page-break-after: always;
               page-break-inside: avoid;
           }
           #tracking-sheet-container .tracking-sheet-print-container:last-of-type {
               page-break-after: avoid;
           }
           @page tracking-sheet-page {
              size: letter landscape;
              margin: 0.25in;
           }
           #tracking-sheet-container {
               page: tracking-sheet-page;
           }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
    <div id="input-container">
        <div id="header-container">
            <h1>Panel Form Reuse Schedule</h1>
            <div class="action-buttons">
                <button id="generate-schedule" disabled>Generate Schedule</button>
            </div>
            <div class="input-option">
                <h3>Project Details</h3>
                <div class="paste-area">
                    <label for="project-name-input"><strong>Project Name</strong></label>
                    <input type="text" id="project-name-input" placeholder="e.g., Project X">
                </div>
            </div>
            <div class="input-option">
                <h3>Upload a File</h3>
                <p>Select a single <strong>Excel (.xlsx)</strong> or <strong>CSV (.csv)</strong> file.</p>
                <p><small><b>For Excel:</b> Ensure your data is on sheets named "Panel Legend" and "Casting Schedule".<br><b>For CSV:</b> The file should contain both the "Panel Legend" and "Casting Schedule" sections.</small></p>
                <input type="file" id="file-input" accept=".csv,.xlsx,.xls">
                <p><small><b>To export from Google Sheets:</b> Open your sheet, go to <i>File > Download > Microsoft Excel (.xlsx)</i>.</small></p>
                <div class="template-link-container">
                    <a href="https://docs.google.com/spreadsheets/d/1etTFuqcqPBHPw2U1r-XG92rKT9JYsUP_-QtnDHiNczk/edit?usp=sharing" class="template-link" target="_blank">Get Project Panel List Template</a>
                </div>
            </div>
            <div class="input-option">
                <h3>Constraints (Optional)</h3>
                <p>Set a maximum length and/or width for newly created forms. This can be useful to match available material sizes.</p>
                <div class="paste-area">
                    <label for="max-length-input"><strong>Max Form Length (inches)</strong></label>
                    <input type="number" id="max-length-input" placeholder="e.g., 240">
                </div>
                <div class="paste-area">
                    <label for="max-width-input"><strong>Max Form Width (inches)</strong></label>
                    <input type="number" id="max-width-input" placeholder="e.g., 96">
                </div>
            </div>
        </div>
        <div class="input-option">
            <h3>Pre-existing Forms (Optional)</h3>
            <p>Enter the dimensions and quantity of pre-existing forms available.</p>
            <div id="pre-existing-forms-container">
                <div class="form-row">
                    <span>Form 1</span>
                    <input type="number" placeholder="Width" class="pre-existing-width">
                    <input type="number" placeholder="Length" class="pre-existing-length">
                    <input type="number" placeholder="Quantity" class="pre-existing-qty" value="1">
                </div>
            </div>
            <button id="add-form-row">+</button>
        </div>
    </div>
    <div id="output-controls" style="display: none; padding: 10px; background-color: var(--light-bg); border: 1px solid var(--border-color); border-radius: 4px;">
        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
            <div id="nav-left-controls">
                <button id="start-over">Start Over</button>
                <button id="back-to-schedule-button" style="display: none;">Back to Schedule</button>
                <button id="back-to-review-button">Back to Review</button>
            </div>
            <div id="nav-middle-controls">
                <button id="print-schedule-button" disabled>Print Schedule</button>
                <small id="print-note" style="display: none;">(For best results, use your browser's 'Fit to page' or scale options in the print preview)</small>
            </div>
            <div id="nav-right-controls">
               <button id="generate-tracking-sheet-button" disabled>Generate Tracking Sheet</button>
               <button id="generate-stickers-button" disabled>Generate Stickers</button>
            </div>
        </div>
        <div class="explanation-section" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border-color);">
            <h4 style="margin-top: 0;">How This Schedule is Optimized</h4>
            <p style="font-size: 0.9em; margin-bottom: 0.5em;">This schedule minimizes waste and reduces the total number of forms built by intelligently reusing formwork. It prioritizes using existing forms that fit the required panel dimensions, making adjustments with fillers as needed.</p>
            <p style="font-size: 0.9em; margin-bottom: 0;">When a new form must be created, the program analyzes all future casting requirements to determine an optimal new form size—one that will be most useful for upcoming panels. This forward-looking approach avoids creating single-use forms and ensures materials are used efficiently.</p>
        </div>
    </div>
    <div id="review-actions">
        <button id="cancel-review">Back</button>
        <button id="confirm-generate">Confirm and Generate Schedule</button>
    </div>
    <div id="review-container">
        <h2>Review Parsed Data</h2>
        <p>Please review the parsed Panel Legend and Casting Schedule below. If it looks correct, click "Confirm and Generate Schedule".</p>
        <div class="review-section">
            <h3>Panel Legend</h3>
            <div id="review-panel-legend"></div>
        </div>
        <div class="review-section">
            <h3>Casting Schedule</h3>
            <div id="review-casting-schedule"></div>
        </div>
    </div>
    <div id="output">
        <p>Please upload a CSV file and click "Generate Schedule".</p>
    </div>
<div id="sticker-settings-container" style="display: none; padding: 20px; background-color: var(--light-bg); border: 1px solid var(--border-color); margin-bottom: 20px; border-radius: 4px;">
        <h3 style="margin-top: 0;">Sticker Sheet Layout Settings</h3>
        <p>Adjust the layout to match your sticker paper. The default values are for a standard 30-label sheet (e.g., Avery 5160 / Sheet-Labels SL100).</p>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
            <div class="paste-area">
                <label for="sticker-width">Sticker Width (inches)</label>
                <input type="number" id="sticker-width" value="2.625" step="0.001">
            </div>
            <div class="paste-area">
                <label for="sticker-height">Sticker Height (inches)</label>
                <input type="number" id="sticker-height" value="1" step="0.001">
            </div>
            <div class="paste-area">
                <label for="sticker-cols">Columns per Sheet</label>
                <input type="number" id="sticker-cols" value="3" step="1">
            </div>
            <div class="paste-area">
                <label for="sticker-rows">Rows per Sheet</label>
                <input type="number" id="sticker-rows" value="10" step="1">
            </div>
            <div class="paste-area">
                <label for="sheet-margin-top">Top/Bottom Margin (inches)</label>
                <input type="number" id="sheet-margin-top" value="0.5" step="0.001">
            </div>
            <div class="paste-area">
                <label for="sheet-margin-left">Left/Right Margin (inches)</label>
                <input type="number" id="sheet-margin-left" value="0.1875" step="0.001">
            </div>
            <div class="paste-area">
                <label for="gap-vertical">Vertical Gap (inches)</label>
                <input type="number" id="gap-vertical" value="0" step="0.001">
            </div>
            <div class="paste-area">
                <label for="gap-horizontal">Horizontal Gap (inches)</label>
                <input type="number" id="gap-horizontal" value="0.15625" step="0.001">
            </div>
        </div>
        <div style="margin-top: 20px;">
            <button id="confirm-generate-stickers">Generate &amp; View Stickers</button>
            <button id="cancel-sticker-generation" style="background-color: var(--disabled-bg);">Cancel</button>
        </div>
    </div>
    <div id="sticker-sheet-container"></div>
    <div id="tracking-sheet-container" style="display: none;"></div>
    <script>
        let formRowCount = 1;
        let appState = {
            panelLegend: null,
            castingSchedule: null,
            projectName: ''
        };
        const fallbackCastingSchedule = [
            { "P21": 4, "P35": 4, "P41": 4 }, { "P21": 4, "P35": 4, "P41": 4 }, { "P6": 3, "P14": 3, "P21": 1, "P35": 1, "P41": 3, "P42": 3 }, { "P2": 1, "P4": 2, "P10": 1, "P12": 2, "P18": 1, "P21": 3, "P28": 1, "P35": 3 }, { "P7": 3, "P15": 3, "P22": 3, "P30": 3, "P31": 1 }, { "P7": 2, "P15": 2, "P22": 2, "P27": 1, "P30": 2, "P31": 1, "P49": 1, "P50": 1, "P51": 1 }, { "P7": 3, "P15": 3, "P22": 3, "P23": 1, "P30": 1, "P36": 1, "P43": 1 }, { "P6": 2, "P14": 2, "P23": 2, "P30": 1, "P36": 2, "P42": 2, "P43": 2 }, { "P6": 3, "P7": 1, "P14": 2, "P15": 1, "P16": 1, "P22": 1, "P26": 1, "P40": 1, "P42": 2, "P48": 1 }, { "P10": 1, "P14": 4, "P20": 1, "P29": 1, "P42": 2, "P52": 2 }, { "P3": 1, "P13": 1, "P23": 3, "P25": 1, "P26": 2, "P36": 3, "P43": 2, "P52": 2 }, { "P23": 3, "P33": 2, "P36": 3, "P37": 2, "P43": 2, "P44": 1 }, { "P1": 1, "P5": 1, "P9": 1, "P11": 1, "P17": 1, "P32": 1, "P33": 1, "P34": 1, "P37": 1, "P38": 1, "P39": 1, "P44": 2, "P45": 1, "P46": 1 }, { "P11": 2, "P15": 2, "P36": 3, "P38": 2, "P47": 3 }, { "P15": 6, "P36": 6 }, { "P15": 4, "P36": 3 }
        ];
        function parseDim(dimStr) {
            if (typeof dimStr !== 'string') return 0;
            let total = 0;
            const parts = dimStr.replace(/"/g, '').trim().split(' ');
            parts.forEach(part => {
                if (part.includes('/')) {
                    const fraction = part.split('/');
                    total += parseInt(fraction[0], 10) / parseInt(fraction[1], 10);
                } else if (part) {
                    total += parseInt(part, 10);
                }
            });
            return total;
        }
        function parseExcelData(workbook) {
            const legendSheetName = workbook.SheetNames.find(name => name.toLowerCase().includes('panel legend'));
            const scheduleSheetName = workbook.SheetNames.find(name => name.toLowerCase().includes('casting schedule'));
            if (!legendSheetName) {
                throw new Error('Could not find a sheet named "Panel Legend" in the Excel file.');
            }
            // --- Parse Panel Legend ---
            const panelLegendSheet = workbook.Sheets[legendSheetName];
            const panelLegendJson = XLSX.utils.sheet_to_json(panelLegendSheet, { header: 1, defval: "" });
            const panelLegend = {};
            for (let i = 1; i < panelLegendJson.length; i++) {
                const row = panelLegendJson[i];
                if (row && row.length > 0 && row[0]) {
                    const panelId = String(row[0]).trim();
                    if (panelId) {
                        panelLegend[panelId] = {
                            length: String(row[1] || '').trim(),
                            width: String(row[2] || '').trim(),
                            thickness: String(row[3] || '').trim(),
                            castingType: String(row[4] || '').trim(),
                            finish: String(row[5] || '').trim(),
                            color: String(row[6] || '').trim(),
                            comments: String(row[7] || '').trim()
                        };
                    }
                }
            }
            // --- Parse Casting Schedule ---
            let castingSchedule = [];
            if (scheduleSheetName) {
                const scheduleSheet = workbook.Sheets[scheduleSheetName];
                const scheduleJson = XLSX.utils.sheet_to_json(scheduleSheet, { header: 1, defval: "" });
                if (scheduleJson.length > 1) {
                    const headers = scheduleJson[0].map(h => String(h).trim());
                    for (let i = 1; i < scheduleJson.length; i++) {
                        const row = scheduleJson[i];
                        if (!row || row.length === 0 || row.every(cell => cell === "" || cell === null || cell === undefined)) continue;
                        const cast = {};
                        for (let j = 1; j < headers.length; j++) {
                            const panelId = headers[j];
                            const qtyRaw = row[j];
                            if (panelId && (qtyRaw !== undefined && qtyRaw !== null && qtyRaw !== "")) {
                                const qty = parseInt(String(qtyRaw).trim(), 10);
                                if (!isNaN(qty) && qty > 0) {
                                    cast[panelId] = qty;
                                }
                            }
                        }
                        if (Object.keys(cast).length > 0) {
                            castingSchedule.push(cast);
                        }
                    }
                }
            }
            if (castingSchedule.length === 0) {
                console.log("Casting schedule not found or empty in the file, using fallback schedule.");
                castingSchedule = fallbackCastingSchedule;
            }
            return { panelLegend, castingSchedule };
        }
        function parseCsv(csvText) {
            const lines = csvText.trim().split(/\r?\n/);
            const legendHeaderIndex = lines.findIndex(line => line.toLowerCase().includes('panel legend'));
            const scheduleHeaderIndex = lines.findIndex(line => line.toLowerCase().includes('casting schedule'));
            let panelLegendLines = [];
            let castingScheduleLines = [];
            if (legendHeaderIndex !== -1) {
                if (scheduleHeaderIndex !== -1) {
                    panelLegendLines = lines.slice(legendHeaderIndex + 1, scheduleHeaderIndex);
                    castingScheduleLines = lines.slice(scheduleHeaderIndex + 1);
                } else {
                    panelLegendLines = lines.slice(legendHeaderIndex + 1);
                }
            } else {
                panelLegendLines = lines.slice(1);
            }
            const panelLegend = {};
            panelLegendLines.forEach(line => {
                if (!line.trim()) return;
                const parts = line.split(',');
                if (parts.length >= 3) {
                    const panelId = parts[0].trim();
                    if (panelId) {
                        const lengthRaw = parts[1].trim();
                        const widthRaw = parts[2].trim();
                        const length = lengthRaw.substring(1, lengthRaw.length - 1).replace(/""/g, '"');
                        const width = widthRaw.substring(1, widthRaw.length - 1).replace(/""/g, '"');
                        panelLegend[panelId] = { length, width };
                    }
                }
            });
            let castingSchedule = [];
            if (castingScheduleLines.length > 0) {
                castingScheduleLines.forEach(line => {
                    if (!line.trim()) return;
                    const cast = {};
                    const parts = line.split(',');
                    for (let i = 0; i < parts.length; i += 2) {
                        const panelId = parts[i].trim();
                        const qty = parseInt(parts[i+1].trim(), 10);
                        if (panelId && !isNaN(qty)) {
                            cast[panelId] = qty;
                        }
                    }
                    if (Object.keys(cast).length > 0) {
                        castingSchedule.push(cast);
                    }
                });
            }
            if (castingSchedule.length === 0) {
                castingSchedule = fallbackCastingSchedule;
            }
            return { panelLegend, castingSchedule };
        }
        function findOptimalFormSize(panelLegend, allPanels, constraints = {}, minimums = {}) {
            const { maxLength = Infinity, maxWidth = Infinity } = constraints;
            const { minLength = 0, minWidth = 0 } = minimums;
            if (allPanels.length === 0) {
                const optimalLength = Math.min(minLength, maxLength);
                const optimalWidth = Math.min(minWidth, maxWidth);
                return { optimalLength: optimalLength, optimalWidth: Math.max(optimalWidth, 50) };
            }
            const panelDimensions = allPanels.map(panelId => {
                const details = panelLegend[panelId];
                if (!details) return null;
                return {
                    id: panelId,
                    length: parseDim(details.length),
                    width: parseDim(details.width)
                };
            }).filter(p => p !== null);
            if (panelDimensions.length === 0) {
                const optimalLength = Math.min(minLength, maxLength);
                const optimalWidth = Math.min(minWidth, maxWidth);
                return { optimalLength: optimalLength, optimalWidth: Math.max(optimalWidth, 50) };
            }
            const uniqueLengths = [...new Set(panelDimensions.map(p => p.length))]
                .filter(l => l <= maxLength)
                .sort((a, b) => a - b);
            const uniqueWidths = [...new Set(panelDimensions.map(p => p.width))]
                .filter(w => w <= maxWidth)
                .sort((a, b) => a - b);
            let bestCombination = {
                length: 0,
                width: 0,
                coveredPanels: -1,
                area: Infinity,
                fillerArea: Infinity
            };
            for (const testLength of uniqueLengths) {
                for (const testWidth of uniqueWidths) {
                    if (testLength < minLength || testWidth < minWidth) continue;
                    const fittingPanels = panelDimensions.filter(p => p.length <= testLength && p.width <= testWidth);
                    const coveredPanels = fittingPanels.length;
                    if (coveredPanels === 0) continue;
                    const area = testLength * testWidth;
                    const totalPanelArea = fittingPanels.reduce((sum, p) => sum + (p.length * p.width), 0);
                    const fillerArea = (coveredPanels * area) - totalPanelArea;
                    if (coveredPanels > bestCombination.coveredPanels) {
                        bestCombination = { length: testLength, width: testWidth, coveredPanels, area, fillerArea };
                    } else if (coveredPanels === bestCombination.coveredPanels) {
                        if (area < bestCombination.area) {
                            bestCombination = { length: testLength, width: testWidth, coveredPanels, area, fillerArea };
                        } else if (area === bestCombination.area) {
                            if (fillerArea < bestCombination.fillerArea) {
                                bestCombination = { length: testLength, width: testWidth, coveredPanels, area, fillerArea };
                            }
                        }
                    }
                }
            }
            let finalLength = bestCombination.length;
            let finalWidth = bestCombination.width;
            if (finalLength === 0) {
                finalLength = Math.min(minLength, maxLength);
                finalWidth = Math.min(minWidth, maxWidth);
            }
            console.log('Optimal form size calculated:', { length: finalLength, width: finalWidth });
            return {
                optimalLength: finalLength,
                optimalWidth: Math.max(finalWidth, 50)
            };
        }
        function generateSchedule(panelLegend, castingSchedule) {
            const maxLengthInput = document.getElementById('max-length-input').value;
            const maxWidthInput = document.getElementById('max-width-input').value;
            const constraints = {
                maxLength: maxLengthInput ? parseInt(maxLengthInput, 10) : Infinity,
                maxWidth: maxWidthInput ? parseInt(maxWidthInput, 10) : Infinity,
            };
            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = '';
            document.getElementById('print-schedule-button').disabled = true;
            document.getElementById('print-note').style.display = 'none';
            let formInventory = [];
            let nextFormId = 1;
            const formRows = document.querySelectorAll('#pre-existing-forms-container .form-row');
            formRows.forEach(row => {
                const widthInput = row.querySelector('.pre-existing-width');
                const lengthInput = row.querySelector('.pre-existing-length');
                const qtyInput = row.querySelector('.pre-existing-qty');
                const width = parseInt(widthInput.value, 10);
                const length = parseInt(lengthInput.value, 10);
                const quantity = parseInt(qtyInput.value, 10);
                if (!isNaN(width) && width > 0 && !isNaN(length) && length > 0 && !isNaN(quantity) && quantity > 0) {
                    for (let i = 0; i < quantity; i++) {
                        formInventory.push({
                            id: nextFormId++,
                            formLength: length,
                            initialWidth: width,
                            lastUsedFor: 'Pre-existing',
                            lastUsedPanelWidth: width,
                            lastUsedPanelLengthStr: `${length}"`,
                            lastUsedPanelWidthStr: `${width}"`,
                        });
                    }
                }
            });
            let fullOutput = '';
            castingSchedule.forEach((cast, castIndex) => {
                const castNumber = castIndex + 1;
                let availableForms = [...formInventory];
                const usedThisCast = [];
                const productionActions = [];
                const storeActions = [];
                const requiredPanels = cast;
                const requiredPanelsList = [];
                for (const panelId in requiredPanels) {
                    if (!panelLegend[panelId]) {
                        console.warn(`Panel ID ${panelId} not found in legend. Skipping.`);
                        continue;
                    }
                    for (let i = 0; i < requiredPanels[panelId]; i++) {
                        requiredPanelsList.push(panelId);
                    }
                }
                requiredPanelsList.forEach((panelId, panelIndex) => {
                    const panelDetails = panelLegend[panelId];
                    const requiredLength = parseDim(panelDetails.length);
                    const requiredWidth = parseDim(panelDetails.width);
                    let formFoundAndUsed = false;
                    let bestFormToReuse = null;
                    const suitableForms = availableForms.filter(f => f.formLength >= requiredLength && f.initialWidth >= requiredWidth);
                    if (suitableForms.length > 0) {
                        suitableForms.forEach(f => {
                            f.score = (f.formLength * f.initialWidth) - (requiredLength * requiredWidth);
                            if (f.formLength === requiredLength) f.score -= 10000;
                            if (f.initialWidth === requiredWidth) f.score -= 1000;
                        });
                        suitableForms.sort((a, b) => a.score - b.score);
                        bestFormToReuse = suitableForms[0];
                    }
                    if (bestFormToReuse) {
                        const form = bestFormToReuse;
                        let note = '';
                        if (form.lastUsedFor === 'Pre-existing') {
                            note = 'Utilized pre-existing form. ';
                        }
                        if (form.formLength === requiredLength && form.initialWidth === requiredWidth) {
                            note += 'Exact form match; no modification needed.';
                        } else if (form.formLength === requiredLength) {
                            note += `Adjust fillers to ${panelDetails.width} width.`;
                        } else if (form.initialWidth === requiredWidth) {
                            note += `Adjust fillers to ${panelDetails.length} length.`;
                        } else {
                            note += `Adjust fillers to ${panelDetails.length} length and ${panelDetails.width} width.`;
                        }
                        productionActions.push({
                            action: `Reuse (${form.lastUsedFor} -> <strong>${panelId}</strong>)`,
                            qty: 1,
                            dimensions: `${panelDetails.length} L x ${panelDetails.width} W`,
                            notes: note
                        });
                        form.lastUsedFor = panelId;
                        form.lastUsedPanelWidth = requiredWidth;
                        form.lastUsedPanelLengthStr = panelDetails.length;
                        form.lastUsedPanelWidthStr = panelDetails.width;
                        usedThisCast.push(form);
                        availableForms = availableForms.filter(f => f.id !== form.id);
                        formFoundAndUsed = true;
                    }
                    if (!formFoundAndUsed) {
                        const remainingForThisCast = requiredPanelsList.slice(panelIndex);
                        const futureCasts = castingSchedule.slice(castIndex + 1);
                        const futurePanels = [];
                        futureCasts.forEach(futureCast => {
                            for (const pId in futureCast) {
                                for (let i = 0; i < futureCast[pId]; i++) {
                                    futurePanels.push(pId);
                                }
                            }
                        });
                        const allRemainingPanels = remainingForThisCast.concat(futurePanels);
                        const { optimalLength, optimalWidth } = findOptimalFormSize(
                            panelLegend,
                            allRemainingPanels,
                            constraints,
                            { minLength: requiredLength, minWidth: requiredWidth }
                        );
                        const newFormLength = optimalLength;
                        const newFormWidth = optimalWidth;
                        const newForm = {
                            id: nextFormId++,
                            formLength: newFormLength,
                            initialWidth: newFormWidth,
                            lastUsedFor: panelId,
                            lastUsedPanelWidth: requiredWidth,
                            lastUsedPanelLengthStr: panelDetails.length,
                            lastUsedPanelWidthStr: panelDetails.width,
                        };
                        formInventory.push(newForm);
                        usedThisCast.push(newForm);
                        let note = `New form built (${newFormLength}" L x ${newFormWidth}" W). Set fillers for ${panelDetails.length} L x ${panelDetails.width} W.`;
                        if (requiredLength > newFormLength || requiredWidth > newFormWidth) {
                            note += ` <strong>WARNING: Panel may not fit. Required: ${requiredLength}"x${requiredWidth}". Form constrained to ${newFormLength}"x${newFormWidth}".</strong>`;
                        }
                        productionActions.push({
                            action: `New (for <strong>${panelId}</strong>)`,
                            qty: 1,
                            dimensions: `${panelDetails.length} L x ${panelDetails.width} W`,
                            notes: note
                        });
                    }
                });
                formInventory = [...usedThisCast, ...availableForms];
                availableForms.forEach(form => {
                    storeActions.push({
                        action: `Store (Last used for <strong>${form.lastUsedFor}</strong>)`,
                        qty: 1,
                        dimensions: `Form: ${form.lastUsedPanelLengthStr} L x ${form.initialWidth}" W`,
                        notes: "Store form; no modification."
                    });
                });
                fullOutput += `<div class="cast-schedule-print-container">`;
                fullOutput += `<h3>Cast ${castNumber}</h3>`;
                fullOutput += `
                    <table class="schedule-table">
                        <tr>
                            <th>Action / Status Detail</th>
                            <th>Qty</th>
                            <th>Dimensions</th>
                            <th>Modification Notes</th>
                        </tr>
                        <tr><td colspan="4"><strong>--- Forms Put into Production ---</strong></td></tr>
                `;
                const aggregatedActions = {};
                productionActions.forEach(pa => {
                    const key = `${pa.action}|${pa.dimensions}|${pa.notes}`;
                    if (!aggregatedActions[key]) {
                        aggregatedActions[key] = { ...pa, qty: 0 };
                    }
                    aggregatedActions[key].qty += pa.qty;
                });
                for(const key in aggregatedActions) {
                    const action = aggregatedActions[key];
                    fullOutput += `<tr><td>${action.action}</td><td>${action.qty}</td><td>${action.dimensions}</td><td>${action.notes}</td></tr>`;
                }
                if (storeActions.length > 0) {
                    fullOutput += `<tr><td colspan="4"><strong>--- Store Forms ---</strong></td></tr>`;
                    const aggregatedStorage = {};
                    storeActions.forEach(sa => {
                        const key = `${sa.action}|${sa.dimensions}|${sa.notes}`;
                        if (!aggregatedStorage[key]) {
                            aggregatedStorage[key] = { ...sa, qty: 0 };
                        }
                        aggregatedStorage[key].qty += sa.qty;
                    });
                    for(const key in aggregatedStorage) {
                        const action = aggregatedStorage[key];
                        fullOutput += `<tr><td>${action.action}</td><td>${action.qty}</td><td>${action.dimensions}</td><td>${action.notes}</td></tr>`;
                    }
                }
                fullOutput += `</table>`;
                fullOutput += `<div class="explanation-section">`;
                fullOutput += `<h4>Explanation of Stored Forms</h4>`;
                if (storeActions.length > 0) {
                    const totalStored = storeActions.reduce((sum, action) => sum + action.qty, 0);
                    fullOutput += `<p>* (${totalStored}) forms were stored because there were no remaining panel requirements in this cast that could be produced on them.</p>`;
                } else {
                    fullOutput += `<p>No forms were stored in this cast as all available forms were utilized for production.</p>`;
                }
                fullOutput += `</div>`;
                fullOutput += `<p><strong>Ending Form Inventory: ${formInventory.length} forms total.</strong></p>`;
                fullOutput += `</div>`;
            });
            // Setup nav for schedule view
            document.getElementById('back-to-review-button').style.display = 'inline-block';
            document.getElementById('start-over').style.display = 'inline-block';

            document.getElementById('print-schedule-button').style.display = 'inline-block';
            document.getElementById('print-schedule-button').disabled = false;
            document.getElementById('print-note').style.display = 'inline';

            document.getElementById('generate-stickers-button').style.display = 'inline-block';
            document.getElementById('generate-stickers-button').disabled = false;
            document.getElementById('generate-tracking-sheet-button').disabled = false;

             // Hide others
             document.getElementById('back-to-schedule-button').style.display = 'none';
            const trackingPrintButton = document.getElementById('print-tracking-sheet-button');
            if (trackingPrintButton) trackingPrintButton.remove();
            const stickerPrintButton = document.getElementById('print-stickers-button');
            if (stickerPrintButton) stickerPrintButton.remove();
            let inventorySummary = '';
            const preExistingForms = formInventory.filter(f => f.lastUsedFor === 'Pre-existing');
            if (preExistingForms.length > 0) {
                inventorySummary += `<h3>Initial Form Inventory</h3>`;
                let inventoryList = `<table class="schedule-table"><tr><th>Form ID</th><th>Dimensions</th></tr>`;
                preExistingForms.forEach(form => {
                    inventoryList += `<tr><td>${form.id}</td><td>${form.formLength}" L x ${form.initialWidth}" W</td></tr>`;
                });
                inventoryList += '</table><hr>';
                inventorySummary += inventoryList;
            }
            outputDiv.innerHTML = inventorySummary + fullOutput;
        }
       function printSchedule() {
           window.print();
       }
        function displayReviewData() {
            const { panelLegend, castingSchedule } = appState;
            const legendDiv = document.getElementById('review-panel-legend');
            const scheduleDiv = document.getElementById('review-casting-schedule');
            let legendHtml = '<table><tr><th>Panel ID</th><th>Length</th><th>Width</th><th>Thickness</th><th>Casting Type</th><th>Finish</th><th>Color</th><th>Comments</th></tr>';
            for (const id in panelLegend) {
                const panel = panelLegend[id];
                legendHtml += `<tr>
                    <td>${id}</td>
                    <td>${panel.length}</td>
                    <td>${panel.width}</td>
                    <td>${panel.thickness}</td>
                    <td>${panel.castingType}</td>
                    <td>${panel.finish}</td>
                    <td>${panel.color}</td>
                    <td>${panel.comments}</td>
                </tr>`;
            }
            legendHtml += '</table>';
            legendDiv.innerHTML = legendHtml;
            let scheduleHtml = '<table><tr><th style="width:10%;">Cast #</th><th>Panels (Qty)</th></tr>';
            castingSchedule.forEach((cast, index) => {
                const panelList = Object.entries(cast)
                    .map(([panelId, qty]) => `${panelId}: ${qty}`)
                    .join(', ');
                scheduleHtml += `<tr><td>${index + 1}</td><td>${panelList}</td></tr>`;
            });
            scheduleHtml += '</table>';
            scheduleDiv.innerHTML = scheduleHtml;
            document.getElementById('input-container').style.display = 'none';
            const reviewActions = document.getElementById('review-actions');
            reviewActions.style.top = `0px`;
            reviewActions.style.display = 'flex';
            document.getElementById('review-container').style.display = 'block';
            document.getElementById('output').style.display = 'none';
        }
        document.getElementById('generate-schedule').addEventListener('click', () => {
            const fileInput = document.getElementById('file-input');
            if (fileInput.files.length === 0) {
                alert('Please select a file to upload.');
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = event.target.result;
                    let parsedData;
                    if (file.name.endsWith('.csv')) {
                        parsedData = parseCsv(data);
                    } else {
                        const workbook = XLSX.read(data, { type: 'binary' });
                        parsedData = parseExcelData(workbook);
                    }
                    processData(parsedData);
                } catch (error) {
                    alert('Error processing file: ' + error.message);
                    console.error(error);
                }
            };
            reader.onerror = function(error) {
                alert('Failed to read file.');
                console.error('FileReader error:', error);
            };
            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsBinaryString(file);
            }
        });
        function processData({ panelLegend, castingSchedule }) {
            if (!panelLegend || Object.keys(panelLegend).length === 0) {
                alert('Could not parse Panel Legend from the provided data.');
                return;
            }
            appState.panelLegend = panelLegend;
            appState.castingSchedule = castingSchedule;
            appState.projectName = document.getElementById('project-name-input').value || 'N/A';
            displayReviewData();
        }
        function updateGenerateButtonState() {
            const fileInput = document.getElementById('file-input');
            const generateButton = document.getElementById('generate-schedule');
            if (fileInput.files.length > 0) {
                generateButton.disabled = false;
            } else {
                generateButton.disabled = true;
            }
        }
        document.getElementById('confirm-generate').addEventListener('click', () => {
            document.getElementById('review-actions').style.display = 'none';
            document.getElementById('review-container').style.display = 'none';
            document.getElementById('output').style.display = 'block';
            document.getElementById('output-controls').style.display = 'block';
            generateSchedule(appState.panelLegend, appState.castingSchedule);
        });
        document.getElementById('back-to-review-button').addEventListener('click', () => {
            document.getElementById('output').style.display = 'none';
            document.getElementById('output-controls').style.display = 'none';
            document.getElementById('sticker-sheet-container').style.display = 'none';
            document.getElementById('tracking-sheet-container').style.display = 'none';

            const trackingPrintButton = document.getElementById('print-tracking-sheet-button');
            if (trackingPrintButton) trackingPrintButton.remove();
            const stickerPrintButton = document.getElementById('print-stickers-button');
            if (stickerPrintButton) stickerPrintButton.remove();
            
            displayReviewData();
        });
        document.getElementById('cancel-review').addEventListener('click', () => {
            document.getElementById('review-actions').style.display = 'none';
            document.getElementById('review-container').style.display = 'none';
            document.getElementById('output').style.display = 'block';
            document.getElementById('input-container').style.display = 'block';
            document.getElementById('file-input').value = '';
            const container = document.getElementById('pre-existing-forms-container');
            container.innerHTML = `
                <div class="form-row">
                    <span>Form 1</span>
                    <input type="number" placeholder="Width" class="pre-existing-width">
                    <input type="number" placeholder="Length" class="pre-existing-length">
                    <input type="number" placeholder="Quantity" class="pre-existing-qty" value="1">
                </div>
            `;
            formRowCount = 1;
        });
        document.getElementById('file-input').addEventListener('change', updateGenerateButtonState);
        document.addEventListener('DOMContentLoaded', updateGenerateButtonState);
        document.getElementById('add-form-row').addEventListener('click', () => {
            formRowCount++;
            const container = document.getElementById('pre-existing-forms-container');
            const newRow = document.createElement('div');
            newRow.className = 'form-row';
            newRow.innerHTML = `
                <span>Form ${formRowCount}</span>
                <input type="number" placeholder="Width" class="pre-existing-width">
                <input type="number" placeholder="Length" class="pre-existing-length">
                <input type="number" placeholder="Quantity" class="pre-existing-qty" value="1">
            `;
            container.appendChild(newRow);
        });
        document.getElementById('print-schedule-button').addEventListener('click', printSchedule);
        document.getElementById('start-over').addEventListener('click', () => {
            document.getElementById('output').style.display = 'none';
            document.getElementById('output-controls').style.display = 'none';
            document.getElementById('input-container').style.display = 'block';
            document.getElementById('file-input').value = '';
            appState.panelLegend = null;
            appState.castingSchedule = null;
            document.getElementById('output').innerHTML = '<p>Please upload a CSV file and click "Generate Schedule".</p>';
        });
       document.getElementById('generate-stickers-button').addEventListener('click', () => {
            if (!appState.panelLegend || !appState.castingSchedule) {
                alert('Please generate a schedule first.');
                return;
            }
            // Show sticker settings
            document.getElementById('output').style.display = 'none';
            document.getElementById('tracking-sheet-container').style.display = 'none';
            document.getElementById('sticker-sheet-container').style.display = 'none';
            document.getElementById('output-controls').style.display = 'none';
            document.getElementById('sticker-settings-container').style.display = 'block';
       });
       document.getElementById('back-to-schedule-button').addEventListener('click', () => {
           document.getElementById('sticker-sheet-container').style.display = 'none';
           document.getElementById('sticker-settings-container').style.display = 'none';
           document.getElementById('tracking-sheet-container').style.display = 'none';
           document.getElementById('output').style.display = 'block';
           document.getElementById('output-controls').style.display = 'block';
           
           // Left
           document.getElementById('start-over').style.display = 'inline-block';
           document.getElementById('back-to-review-button').style.display = 'inline-block';
           document.getElementById('back-to-schedule-button').style.display = 'none';
 
           // Middle
           document.getElementById('print-schedule-button').style.display = 'inline-block';
           document.getElementById('print-note').style.display = 'inline';
 
           // Right
           document.getElementById('generate-stickers-button').style.display = 'inline-block';
           document.getElementById('generate-tracking-sheet-button').style.display = 'inline-block';
 
           const stickerPrintButton = document.getElementById('print-stickers-button');
           if (stickerPrintButton) stickerPrintButton.remove();
           const trackingPrintButton = document.getElementById('print-tracking-sheet-button');
           if (trackingPrintButton) trackingPrintButton.remove();
 
           const stickerStyle = document.getElementById('dynamic-sticker-style');
           if(stickerStyle) stickerStyle.remove();
       });


       function generateStickers() {
            const { panelLegend, castingSchedule, projectName } = appState;

            // Read layout settings from the form
            const settings = {
                width: parseFloat(document.getElementById('sticker-width').value),
                height: parseFloat(document.getElementById('sticker-height').value),
                cols: parseInt(document.getElementById('sticker-cols').value, 10),
                rows: parseInt(document.getElementById('sticker-rows').value, 10),
                marginTop: parseFloat(document.getElementById('sheet-margin-top').value),
                marginLeft: parseFloat(document.getElementById('sheet-margin-left').value),
                gapV: parseFloat(document.getElementById('gap-vertical').value),
                gapH: parseFloat(document.getElementById('gap-horizontal').value)
            };
            const stickersPerPage = settings.cols * settings.rows;

            // Generate unique panel IDs
            let panelInstanceCounter = {};
            const allPanelsWithUniqueIds = [];
            castingSchedule.forEach(cast => {
                const sortedPanelIds = Object.keys(cast).sort();
                for (const panelId of sortedPanelIds) {
                    for (let i = 0; i < cast[panelId]; i++) {
                        if (!panelInstanceCounter[panelId]) {
                            panelInstanceCounter[panelId] = 0;
                        }
                        panelInstanceCounter[panelId]++;
                        const uniqueId = `${panelId}.${String(panelInstanceCounter[panelId]).padStart(2, '0')}`;
                        allPanelsWithUniqueIds.push({ panelId, uniqueId });
                    }
                }
            });

            // --- Dynamic CSS for sticker layout ---
            const existingStyle = document.getElementById('dynamic-sticker-style');
            if (existingStyle) existingStyle.remove();

            const style = document.createElement('style');
            style.id = 'dynamic-sticker-style';
            style.innerHTML = `
                .sticker-sheet {
                    display: grid;
                    grid-template-columns: repeat(${settings.cols}, ${settings.width}in);
                    grid-template-rows: repeat(${settings.rows}, ${settings.height}in);
                    gap: ${settings.gapV}in ${settings.gapH}in;
                    width: 8.5in;
                    min-height: 11in; /* Use min-height to allow content to grow */
                    padding: ${settings.marginTop}in ${settings.marginLeft}in;
                    box-sizing: border-box;
                    background-color: #fff;
                    page-break-after: always; /* Ensure each sheet is on a new page when printing */
                }
                .sticker-sheet:last-of-type {
                    page-break-after: avoid;
                }
                .sticker {
                    width: ${settings.width}in;
                    height: ${settings.height}in;
                    border: 1px solid #ccc; /* Use a light border for on-screen view */
                    box-sizing: border-box;
                    padding: 4px;
                    font-size: 7pt;
                    color: #000;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                    justify-content: space-between;
                }
                @media print {
                    .sticker {
                        border: 1px solid #000; /* Make border darker for printing */
                    }
                    .sticker-sheet {
                        box-shadow: none;
                    }
                }
            `;
            document.head.appendChild(style);

            const stickerContainer = document.getElementById('sticker-sheet-container');
            stickerContainer.innerHTML = ''; // Clear previous content

            // Create and populate sticker sheets
            for (let i = 0; i < allPanelsWithUniqueIds.length; i += stickersPerPage) {
                const sheetPanels = allPanelsWithUniqueIds.slice(i, i + stickersPerPage);
                const stickerSheet = document.createElement('div');
                stickerSheet.className = 'sticker-sheet';

                sheetPanels.forEach(({ panelId, uniqueId }) => {
                    const panel = panelLegend[panelId];
                    if (!panel) return;
                    const sticker = document.createElement('div');
                    sticker.className = 'sticker';
                    sticker.innerHTML = `
                        <div class="sticker-header">
                            <span>${projectName}</span>
                            <span><strong>${uniqueId}</strong></span>
                        </div>
                        <div class="sticker-body">
                            <div class="sticker-dims">
                                L: ${panel.length || 'N/A'} | W: ${panel.width || 'N/A'} | T: ${panel.thickness || 'N/A'}
                            </div>
                            <div class="qc-boxes">
                                <div class="qc-box">M</div>
                                <div class="qc-box">F</div>
                                <div class="qc-box">C</div>
                                <div class="qc-box">W</div>
                            </div>
                        </div>
                        <div class="sticker-footer">
                            <span>${panel.finish || ''}</span>
                            <span>${panel.color || ''}</span>
                        </div>
                    `;
                    stickerSheet.appendChild(sticker);
                });
                stickerContainer.appendChild(stickerSheet);
            }

            // Update UI
            document.getElementById('sticker-settings-container').style.display = 'none';
            stickerContainer.style.display = 'block';
            document.getElementById('output-controls').style.display = 'block'; // Keep controls visible

            // Left
            document.getElementById('back-to-schedule-button').style.display = 'inline-block';

            // Middle
            const middleNav = document.getElementById('nav-middle-controls');
            if (!document.getElementById('print-stickers-button')) {
                const stickerPrintButton = document.createElement('button');
                stickerPrintButton.id = 'print-stickers-button';
                stickerPrintButton.textContent = 'Print Stickers';
                stickerPrintButton.onclick = () => window.print();
                middleNav.appendChild(stickerPrintButton);
            }

            // Hide others
            document.getElementById('start-over').style.display = 'none';
            document.getElementById('back-to-review-button').style.display = 'none';
            document.getElementById('back-to-schedule-button').style.display = 'inline-block';
            document.getElementById('print-schedule-button').style.display = 'none';
            document.getElementById('print-note').style.display = 'none';
            document.getElementById('generate-stickers-button').style.display = 'none';
            document.getElementById('generate-tracking-sheet-button').style.display = 'none';
            const trackingPrintButton = document.getElementById('print-tracking-sheet-button');
            if (trackingPrintButton) trackingPrintButton.remove();
       }

       document.getElementById('confirm-generate-stickers').addEventListener('click', generateStickers);

       document.getElementById('cancel-sticker-generation').addEventListener('click', () => {
            document.getElementById('sticker-settings-container').style.display = 'none';
            // Go back to the main schedule view
            document.getElementById('output').style.display = 'block';
            document.getElementById('output-controls').style.display = 'block';
       });
    </script>
<script>
   function generateTrackingSheet() {
       const { panelLegend, castingSchedule, projectName } = appState;
       if (!panelLegend || !castingSchedule) {
           alert('Please generate a schedule first.');
           return;
       }

       const trackingContainer = document.getElementById('tracking-sheet-container');
       trackingContainer.innerHTML = ''; // Clear previous content

       let panelInstanceCounter = {};
       let fullHtml = `<h1>${projectName} - Panel Tracking Sheets</h1>`;

       castingSchedule.forEach((cast, castIndex) => {
           const castNumber = castIndex + 1;
           fullHtml += `<div class="tracking-sheet-print-container">`;
           fullHtml += `<h3>Cast ${castNumber}</h3>`;
           fullHtml += `<table class="schedule-table">
               <thead>
                   <tr>
                       <th>Panel Unique ID</th>
                       <th>Mill QC</th>
                       <th>Formout QC</th>
                       <th>Casting QC</th>
                       <th>Wash QC</th>
                       <th>Seal QC</th>
                       <th>Crate QC</th>
                       <th>Pack QC</th>
                   </tr>
               </thead>
               <tbody>`;

           const sortedPanelIds = Object.keys(cast).sort();
           for (const panelId of sortedPanelIds) {
               for (let i = 0; i < cast[panelId]; i++) {
                   if (!panelInstanceCounter[panelId]) {
                       panelInstanceCounter[panelId] = 0;
                   }
                   panelInstanceCounter[panelId]++;
                   const uniqueId = `${panelId}.${String(panelInstanceCounter[panelId]).padStart(2, '0')}`;
                   fullHtml += `<tr>
                       <td><strong>${uniqueId}</strong></td>
                       <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
                   </tr>`;
               }
           }

           fullHtml += `</tbody></table></div>`;
       });

       trackingContainer.innerHTML = fullHtml;

       // Update UI
       document.getElementById('output').style.display = 'none';
       document.getElementById('sticker-sheet-container').style.display = 'none';
       document.getElementById('sticker-settings-container').style.display = 'none';
       trackingContainer.style.display = 'block';
       document.getElementById('output-controls').style.display = 'block';

       // Update nav buttons
       document.getElementById('back-to-schedule-button').style.display = 'inline-block';
       document.getElementById('start-over').style.display = 'none';
       document.getElementById('back-to-review-button').style.display = 'none';
       document.getElementById('print-schedule-button').style.display = 'none';
       document.getElementById('generate-stickers-button').style.display = 'inline-block';
       document.getElementById('generate-tracking-sheet-button').style.display = 'none';
       document.getElementById('print-note').style.display = 'none';

       const middleNav = document.getElementById('nav-middle-controls');
       if (!document.getElementById('print-tracking-sheet-button')) {
           const printButton = document.createElement('button');
           printButton.id = 'print-tracking-sheet-button';
           printButton.textContent = 'Print Tracking Sheet';
           printButton.onclick = () => window.print();
           middleNav.appendChild(printButton);
       }
   }

   document.getElementById('generate-tracking-sheet-button').addEventListener('click', generateTrackingSheet);
</script>
</body>
</html>